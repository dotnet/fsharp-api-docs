<Type Name="ArrayModule" FullName="Microsoft.FSharp.Collections.ArrayModule">
  <TypeSignature Language="C#" Value="public static class ArrayModule" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed ArrayModule extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Collections.ArrayModule" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.4.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.Module)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationRepresentation(Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.RequireQualifiedAccess</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Basic operations on arrays.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AllPairs&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1,T2&gt;[] AllPairs&lt;T1,T2&gt; (T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T1, !!T2&gt;[] AllPairs&lt;T1, T2&gt;(!!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.AllPairs``2(``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("allPairs")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1,T2&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Builds a new array that contains the cartesian product of the two input arrays.</summary>
        <returns>The resulting array of pairs.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Append&lt;T&gt; (T[] array1, T[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Append&lt;T&gt;(!!T[] array1, !!T[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Append``1(``0[],``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("append")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array1" Type="T[]" />
        <Parameter Name="array2" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Builds a new array that contains the elements of the first array followed by the elements of the second array.</summary>
        <returns>The resulting array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Average&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Average&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Average``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("average")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the average of the elements in the array.</summary>
        <returns>The average of the elements in the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when <c>array</c> is empty.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="AverageBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult AverageBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult AverageBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("averageBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the array elements before averaging.</param>
        <param name="array">The input array.</param>
        <summary>Returns the average of the elements generated by applying the function to each element of the array.</summary>
        <returns>The computed average.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when <c>array</c> is empty.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Choose&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Choose&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("choose")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">The function to generate options from the elements.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to each element of the array. Returns
 the array comprised of the results "x" for each element where
 the function returns Some(x)</summary>
        <returns>The array of results.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChunkBySize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[][] ChunkBySize&lt;T&gt; (int chunkSize, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[][] ChunkBySize&lt;T&gt;(int32 chunkSize, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ChunkBySize``1(System.Int32,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("chunkBySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[][]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chunkSize" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="chunkSize">The maximum size of each chunk.</param>
        <param name="array">The input array.</param>
        <summary>Divides the input array into chunks of size at most <c>chunkSize</c>.</summary>
        <returns>The array divided into chunks.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when <c>chunkSize</c> is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Collect&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult[]&gt; mapping, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Collect&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult[]&gt; mapping, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1[]},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("collect")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult[]&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to create sub-arrays from the input array elements.</param>
        <param name="array">The input array.</param>
        <summary>For each element of the array, applies the given function. Concatenates all the results and return the combined array.</summary>
        <returns>The concatenation of the sub-arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int CompareWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, T[] array1, T[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 CompareWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, !!T[] array1, !!T[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[],``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("compareWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="array1" Type="T[]" />
        <Parameter Name="array2" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">A function that takes an element from each array and returns an int.
 If it evaluates to a non-zero value iteration is stopped and that value is returned.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Compares two arrays using the given comparison function, element by element.</summary>
        <returns>Returns the first non-zero result from the comparison function. If the first array has 
 a larger element, the return value is always positive. If the second array has a larger 
 element, the return value is always negative. When the elements are equal in the two 
 arrays, 1 is returned if the first array is longer, 0 is returned if they are equal in 
 length, and -1 is returned when the second array is longer.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays
 is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T[]&gt; arrays);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T[]&gt; arrays) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Concat``1(System.Collections.Generic.IEnumerable{``0[]})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("concat")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arrays" Type="System.Collections.Generic.IEnumerable&lt;T[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="arrays">The input sequence of arrays.</param>
        <summary>Builds a new array that contains the elements of each of the given sequence of arrays.</summary>
        <returns>The concatenation of the sequence of input arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (T value, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Contains&lt;T&gt;(!!T value, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Contains``1(``0,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("contains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to locate in the input array.</param>
        <param name="array">The input array.</param>
        <summary>Tests if the array contains the specified element.</summary>
        <returns>True if the input array contains the specified element; false otherwise.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Copy&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Copy&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Copy``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("copy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Builds a new array that contains the elements of the given array.</summary>
        <returns>A copy of the input array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (T[] source, int sourceIndex, T[] target, int targetIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyTo&lt;T&gt;(!!T[] source, int32 sourceIndex, !!T[] target, int32 targetIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.CopyTo``1(``0[],System.Int32,``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("blit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="target" Type="T[]" />
        <Parameter Name="targetIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The source array.</param>
        <param name="sourceIndex">The starting index of the source array.</param>
        <param name="target">The target array.</param>
        <param name="targetIndex">The starting index of the target array.</param>
        <param name="count">The number of elements to copy.</param>
        <summary>Reads a range of elements from the first array and write them into the second.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when any of sourceIndex, targetIndex or count are negative,
 or when there aren't enough elements in source or target.</exception>
      </Docs>
    </Member>
    <Member MemberName="CountBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TKey,int&gt;[] CountBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TKey, int32&gt;[] CountBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("countBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TKey,System.Int32&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function transforming each item of the input array into a key to be
 compared against the others.</param>
        <param name="array">The input array.</param>
        <summary>Applies a key-generating function to each element of an array and returns an array yielding unique
 keys and their number of occurrences in the original array.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Create&lt;T&gt; (int count, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Create&lt;T&gt;(int32 count, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Create``1(System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("create")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The length of the array to create.</param>
        <param name="value">The value for the elements.</param>
        <summary>Creates an array whose elements are all initially the given value.</summary>
        <returns>The created array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Distinct&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Distinct&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Distinct``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("distinct")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns an array that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the array then the later occurrences are discarded.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="DistinctBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static T[] DistinctBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] DistinctBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("distinctBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function transforming the array items into comparable keys.</param>
        <param name="array">The input array.</param>
        <summary>Returns an array that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the array then the later occurrences are discarded.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("empty")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.GeneralizableValue</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Returns an empty array of the given type.</summary>
        <returns>The empty array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactlyOne&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ExactlyOne&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T ExactlyOne&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ExactlyOne``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exactlyOne")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the only element of the array.</summary>
        <returns>The only element of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input does not have precisely one element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Except&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; itemsToExclude, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Except&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; itemsToExclude, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Except``1(System.Collections.Generic.IEnumerable{``0},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("except")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="itemsToExclude" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="itemsToExclude">A sequence whose elements that also occur in the input array will cause those elements to be
 removed from the result.</param>
        <param name="array">An array whose elements that are not also in itemsToExclude will be returned.</param>
        <summary>Returns a new list with the distinct elements of the input array which do not appear in the itemsToExclude sequence,
 using generic hash and equality comparisons to compare values.</summary>
        <returns>An array that contains the distinct elements of <c>array</c> that do not appear in <c>itemsToExclude</c>.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either itemsToExclude or array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Exists&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exists")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Tests if any element of the array satisfies the given predicate.</summary>
        <returns>True if any result from <c>predicate</c> is true.</returns>
        <remarks>The predicate is applied to the elements of the input array. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,bool&gt;&gt; predicate, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Exists2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, bool&gt;&gt; predicate, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exists2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,System.Boolean&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Tests if any pair of corresponding elements of the arrays satisfies the given predicate.</summary>
        <returns>True if any result from <c>predicate</c> is true.</returns>
        <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, false is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] target, int targetIndex, int count, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Fill&lt;T&gt;(!!T[] target, int32 targetIndex, int32 count, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Fill``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fill")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T[]" />
        <Parameter Name="targetIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="target">The target array.</param>
        <param name="targetIndex">The index of the first element to set.</param>
        <param name="count">The number of elements to set.</param>
        <param name="value">The value to set.</param>
        <summary>Fills a range of elements of the array with the given value.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when either targetIndex or count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Filter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Filter&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Filter&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>
        <returns>An array containing the elements for which the given predicate returns true.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Find&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("find")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the first element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
        <returns>The first element for which <c>predicate</c> returns true.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T FindBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the last element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
        <returns>The last element for which <c>predicate</c> returns true.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FindIndex&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findIndex")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisfy the predicate.</summary>
        <returns>The index of the first element in the array that satisfies the given predicate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndexBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndexBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FindIndexBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findIndexBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the index of the last element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if
 none of the elements satisfy the predicate.</summary>
        <returns>The index of the last element in the array that satisfies the given predicate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fold&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState Fold&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt; folder, TState state, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState Fold&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TState&gt;&gt; folder, !!TState state, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="array">The input array.</param>
        <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f s i0)...) iN</c></summary>
        <returns>The final state.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fold2&lt;T1,T2,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState Fold2&lt;T1,T2,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TState&gt;&gt;&gt; folder, TState state, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState Fold2&lt;T1, T2, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TState&gt;&gt;&gt; folder, !!TState state, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fold2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Applies a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The final state.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="FoldBack&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState FoldBack&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt; folder, T[] array, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState FoldBack&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt; folder, !!T[] array, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``0[],``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("foldBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="array">The input array.</param>
        <param name="state">The initial state.</param>
        <summary>Applies a function to each element of the array, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN s))</c></summary>
        <returns>The state object after the folding function is applied to each element of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FoldBack2&lt;T1,T2,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState FoldBack2&lt;T1,T2,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;&gt; folder, T1[] array1, T2[] array2, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState FoldBack2&lt;T1, T2, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt;&gt; folder, !!T1[] array1, !!T2[] array2, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},``0[],``1[],``2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("foldBack2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <param name="state">The initial state.</param>
        <summary>Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The final state.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool ForAll&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("forall")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Tests if all elements of the array satisfy the given predicate.</summary>
        <returns>True if all of the array elements satisfy the predicate.</returns>
        <remarks>The predicate is applied to the elements of the input collection. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForAll2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,bool&gt;&gt; predicate, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool ForAll2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, bool&gt;&gt; predicate, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("forall2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,System.Boolean&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Tests if all corresponding elements of the array satisfy the given predicate pairwise.</summary>
        <returns>True if all of the array elements satisfy the predicate.</returns>
        <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, true is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Get&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Get&lt;T&gt; (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Get&lt;T&gt;(!!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Get``1(``0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("get")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <param name="index">The input index.</param>
        <summary>Gets an element from an array.</summary>
        <returns>The value of the array at the given index.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.NullReferenceException">Thrown when the input array is null.</exception>
        <exception cref="System.IndexOutOfRangeException">Thrown when the index is negative or the input array does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSubArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetSubArray&lt;T&gt; (T[] array, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] GetSubArray&lt;T&gt;(!!T[] array, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.GetSubArray``1(``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sub")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <param name="startIndex">The index of the first element of the sub array.</param>
        <param name="count">The length of the sub array.</param>
        <summary>Builds a new array that contains the given subrange specified by
 starting index and length.</summary>
        <returns>The created sub array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when either startIndex or count is negative,
 or when there aren't enough elements in the input array.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TKey,T[]&gt;[] GroupBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TKey, !!T[]&gt;[] GroupBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("groupBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TKey,T[]&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function that transforms an element of the array into a comparable key.</param>
        <param name="array">The input array.</param>
        <summary>Applies a key-generating function to each element of an array and yields an array of 
 unique keys. Each unique key contains an array of all elements that match 
 to this key.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Head&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Head&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Head&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Head``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("head")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the first element of the array.</summary>
        <returns>The first element of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Indexed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;int,T&gt;[] Indexed&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;int32, !!T&gt;[] Indexed&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Indexed``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("indexed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;System.Int32,T&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Builds a new array whose elements are the corresponding elements of the input array
 paired with the integer index (from 0) of each element.</summary>
        <returns>The array of indexed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Initialize&lt;T&gt; (int count, Microsoft.FSharp.Core.FSharpFunc&lt;int,T&gt; initializer);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Initialize&lt;T&gt;(int32 count, class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, !!T&gt; initializer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("init")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="initializer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of elements to initialize.</param>
        <param name="initializer">The function to generate the initial values for each index.</param>
        <summary>Creates an array given the dimension and a generator function to compute the elements.</summary>
        <returns>The created array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsEmpty&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool IsEmpty&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.IsEmpty``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("isEmpty")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns true if the given array is empty, otherwise false.</summary>
        <returns>True if the array is empty.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Item&lt;T&gt; (int index, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Item&lt;T&gt;(int32 index, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Item``1(System.Int32,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("item")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The input index.</param>
        <param name="array">The input array.</param>
        <summary>Gets an element from an array.</summary>
        <returns>The value of the array at the given index.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.NullReferenceException">Thrown when the input array is null.</exception>
        <exception cref="System.IndexOutOfRangeException">Thrown when the index is negative or the input array does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Iterate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Iterate&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt; action, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Iterate&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt; action, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="action">The function to apply.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to each element of the array.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Iterate2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static void Iterate2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt; action, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Iterate2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.Unit&gt;&gt; action, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iter2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="action">The function to apply.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Applies the given function to pair of elements drawn from matching indices in two arrays. The
 two arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="IterateIndexed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IterateIndexed&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;&gt; action, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void IterateIndexed&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt;&gt; action, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iteri")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="action">The function to apply to each index and element.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to each element of the array. The integer passed to the
 function indicates the index of element.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="IterateIndexed2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static void IterateIndexed2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;&gt; action, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static void IterateIndexed2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.Unit&gt;&gt;&gt; action, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iteri2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="action">The function to apply to each index and pair of elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Applies the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an <c>ArgumentException</c> is raised.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Last&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Last&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Last``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("last")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the last element of the array.</summary>
        <returns>The last element of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Length&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Length&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Length``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("length")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the length of an array. You can also use property arr.Length.</summary>
        <returns>The length of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.NullReferenceException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Map&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Map&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; mapping, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Map&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; mapping, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements of the array.</param>
        <param name="array">The input array.</param>
        <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Map2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Map2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt; mapping, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Map2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt; mapping, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform the pairs of the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Map3&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Map3&lt;T1,T2,T3,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt; mapping, T1[] array1, T2[] array2, T3[] array3);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Map3&lt;T1, T2, T3, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T3, !!TResult&gt;&gt;&gt; mapping, !!T1[] array1, !!T2[] array2, !!T3[] array3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0[],``1[],``2[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
        <Parameter Name="array3" Type="T3[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform the pairs of the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <param name="array3">The third input array.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding triples from the three collections. The three input
 arrays must have the same length, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
        <exception cref="System.ArgumentNullException">Thrown when any of the input arrays is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapFold&lt;T,TState,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TResult[],TState&gt; MapFold&lt;T,TState,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,Tuple&lt;TResult,TState&gt;&gt;&gt; mapping, TState state, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TResult[], !!TState&gt; MapFold&lt;T, TState, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class System.Tuple`2&lt;!!TResult, !!TState&gt;&gt;&gt; mapping, !!TState state, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MapFold``3(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``2,``1}}},``1,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapFold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TResult[],TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Tuple&lt;TResult,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements from the input array and accumulate the final value.</param>
        <param name="state">The initial state.</param>
        <param name="array">The input array.</param>
        <summary>Combines map and fold. Builds a new array whose elements are the results of applying the given function
 to each of the elements of the input array. The function is also used to accumulate a final value.</summary>
        <returns>The array of transformed elements, and the final accumulated value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapFoldBack&lt;T,TState,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TResult[],TState&gt; MapFoldBack&lt;T,TState,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,Tuple&lt;TResult,TState&gt;&gt;&gt; mapping, T[] array, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TResult[], !!TState&gt; MapFoldBack&lt;T, TState, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class System.Tuple`2&lt;!!TResult, !!TState&gt;&gt;&gt; mapping, !!T[] array, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MapFoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},``0[],``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapFoldBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TResult[],TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,System.Tuple&lt;TResult,TState&gt;&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements from the input array and accumulate the final value.</param>
        <param name="array">The input array.</param>
        <param name="state">The initial state.</param>
        <summary>Combines map and foldBack. Builds a new array whose elements are the results of applying the given function
 to each of the elements of the input array. The function is also used to accumulate a final value.</summary>
        <returns>The array of transformed elements, and the final accumulated value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapIndexed&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] MapIndexed&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt; mapping, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] MapIndexed&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt;&gt; mapping, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapi")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements and their indices.</param>
        <param name="array">The input array.</param>
        <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapIndexed2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] MapIndexed2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;&gt; mapping, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] MapIndexed2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt;&gt; mapping, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapi2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform pairs of input elements and their indices.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise, also passing the index of 
 the elements. The two input arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Max&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Max``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("max")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>
        <returns>The maximum element.</returns>
        <remarks>Throws ArgumentException for empty arrays.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T MaxBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T MaxBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("maxBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the elements into a type supporting comparison.</param>
        <param name="array">The input array.</param>
        <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>
        <returns>The maximum element.</returns>
        <remarks>Throws ArgumentException for empty arrays.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Min&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Min``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("min")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the lowest of all elements of the array, compared via Operators.min.</summary>
        <returns>The minimum element.</returns>
        <remarks>Throws ArgumentException for empty arrays</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T MinBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T MinBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("minBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the elements into a type supporting comparison.</param>
        <param name="array">The input array.</param>
        <summary>Returns the lowest of all elements of the array, compared via Operators.min on the function result.</summary>
        <returns>The minimum element.</returns>
        <remarks>Throws ArgumentException for empty arrays.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfList&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] OfList&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] OfList&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ofList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Builds an array from the given list.</summary>
        <returns>The array of elements from the list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OfSeq&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] OfSeq&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] OfSeq&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ofSeq")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Builds a new array from the given enumerable object.</summary>
        <returns>The array of elements from the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pairwise&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T,T&gt;[] Pairwise&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T, !!T&gt;[] Pairwise&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Pairwise``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pairwise")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T,T&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns an array of each element in the input array and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Partition&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T[],T[]&gt; Partition&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T[], !!T[]&gt; Partition&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("partition")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T[],T[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively.</summary>
        <returns>A pair of arrays. The first containing the elements the predicate evaluated to true,
 and the second containing those evaluated to false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Permute&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Permute&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,int&gt; indexMap, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Permute&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, int32&gt; indexMap, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("permute")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="indexMap" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,System.Int32&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="indexMap">The function that maps input indices to output indices.</param>
        <param name="array">The input array.</param>
        <summary>Returns an array with all elements permuted according to the
 specified permutation.</summary>
        <returns>The output array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pick&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Pick&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult Pick&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pick")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">The function to generate options from the elements.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>KeyNotFoundException</c> is raised.</summary>
        <returns>The first result.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if every result from
 <c>chooser</c> is <c>None</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Reduce&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt; reduction, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Reduce&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!T&gt;&gt; reduction, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reduce")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reduction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="reduction">The function to reduce a pair of elements to a single element.</param>
        <param name="array">The input array.</param>
        <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises ArgumentException if the array has size zero.</summary>
        <returns>The final result of the reductions.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReduceBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ReduceBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt; reduction, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T ReduceBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!T&gt;&gt; reduction, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reduceBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reduction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="reduction">A function that takes in the next-to-last element of the list and the
 current accumulated result to produce the next accumulated result.</param>
        <param name="array">The input array.</param>
        <summary>Applies a function to each element of the array, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.</summary>
        <returns>The final result of the reductions.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replicate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Replicate&lt;T&gt; (int count, T initial);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Replicate&lt;T&gt;(int32 count, !!T initial) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Replicate``1(System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("replicate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="initial" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of elements to replicate.</param>
        <param name="initial">The value to replicate</param>
        <summary>Creates an array by replicating the given initial value.</summary>
        <returns>The generated array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Reverse``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("rev")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns a new array with the elements in reverse order.</summary>
        <returns>The reversed array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scan&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState[] Scan&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt; folder, TState state, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState[] Scan&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TState&gt;&gt; folder, !!TState state, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("scan")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="array">The input array.</param>
        <summary>Like <c>fold</c>, but return the intermediary and final results.</summary>
        <returns>The array of state values.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScanBack&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState[] ScanBack&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt; folder, T[] array, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState[] ScanBack&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt; folder, !!T[] array, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``0[],``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("scanBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="array">The input array.</param>
        <param name="state">The initial state.</param>
        <summary>Like <c>foldBack</c>, but return both the intermediary and final results.</summary>
        <returns>The array of state values.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Set&lt;T&gt; (T[] array, int index, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Set&lt;T&gt;(!!T[] array, int32 index, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Set``1(``0[],System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("set")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <param name="index">The input index.</param>
        <param name="value">The input value.</param>
        <summary>Sets an element of an array.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.NullReferenceException">Thrown when the input array is null.</exception>
        <exception cref="System.IndexOutOfRangeException">Thrown when the index is negative or the input array does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Singleton&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Singleton&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Singleton&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Singleton``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("singleton")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input item.</param>
        <summary>Returns an array that contains one item only.</summary>
        <returns>The result array of one item.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Skip&lt;T&gt; (int count, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Skip&lt;T&gt;(int32 count, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Skip``1(System.Int32,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("skip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of elements to skip.</param>
        <param name="array">The input array.</param>
        <summary>Builds a new array that contains the elements of the given array, excluding the first N elements.</summary>
        <returns>A copy of the input array, after removing the first N elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentExcepion">Thrown when count is negative or exceeds the number of 
 elements in the array.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] SkipWhile&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SkipWhile&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("skipWhile")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates an element of the array to a boolean value.</param>
        <param name="array">To be added.</param>
        <summary>Bypasses elements in an array while the given predicate returns True, and then returns
 the remaining elements in a new array.</summary>
        <returns>The created sub array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Sort``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sort")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, returning a new array. Elements are compared using Operators.compare. </summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static T[] SortBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SortBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">The function to transform array elements into the type that is compared.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, using the given projection for the keys and returning a new array. 
 Elements are compared using Operators.compare.</summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortByDescending&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static T[] SortByDescending&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SortByDescending&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortByDescending")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">The function to transform array elements into the type that is compared.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, in descending order, using the given projection for the keys and returning a new array. 
 Elements are compared using Operators.compare.</summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDescending&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] SortDescending&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SortDescending&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortDescending``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortDescending")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, in descending order, returning a new array. Elements are compared using Operators.compare. </summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SortInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SortInPlace&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SortInPlace&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlace``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortInPlace")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function. 
 Elements are compared using Operators.compare.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortInPlaceBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static void SortInPlaceBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SortInPlaceBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortInPlaceBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">The function to transform array elements into the type that is compared.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array by mutating the array in-place, using the given projection for the keys. 
 Elements are compared using Operators.compare.</summary>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortInPlaceWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SortInPlaceWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SortInPlaceWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortInPlaceWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">The function to compare pairs of array elements.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function as the order.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] SortWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SortWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">The function to compare pairs of array elements.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, using the given comparison function as the order, returning a new array.</summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SplitAt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T[],T[]&gt; SplitAt&lt;T&gt; (int index, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T[], !!T[]&gt; SplitAt&lt;T&gt;(int32 index, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SplitAt``1(System.Int32,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("splitAt")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T[],T[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index at which the array is split.</param>
        <param name="array">The input array.</param>
        <summary>Splits an array into two arrays, at the given index.</summary>
        <returns>The two split arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.InvalidOperationException">Thrown when split index exceeds the number of elements
 in the array.</exception>
      </Docs>
    </Member>
    <Member MemberName="SplitInto&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[][] SplitInto&lt;T&gt; (int count, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[][] SplitInto&lt;T&gt;(int32 count, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SplitInto``1(System.Int32,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("splitInto")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[][]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The maximum number of chunks.</param>
        <param name="array">The input array.</param>
        <summary>Splits the input array into at most <c>count</c> chunks.</summary>
        <returns>The array split into chunks.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when <c>count</c> is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Sum&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Sum``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sum")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the sum of the elements in the array.</summary>
        <returns>The resulting sum.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SumBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult SumBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult SumBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sumBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the array elements into the type to be summed.</param>
        <param name="array">The input array.</param>
        <summary>Returns the sum of the results generated by applying the function to each element of the array.</summary>
        <returns>The resulting sum.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Tail&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Tail&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Tail&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Tail``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tail")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns a new array containing the elements of the original except the first element.</summary>
        <returns>A new array containing the elements of the original except the first element.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the array is empty.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Take&lt;T&gt; (int count, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Take&lt;T&gt;(int32 count, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Take``1(System.Int32,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("take")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of items to take.</param>
        <param name="array">The input array.</param>
        <summary>Returns the first N elements of the array.</summary>
        <returns>The result array.</returns>
        <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the array. <c>Array.truncate</c>
 returns as many items as the array contains instead of throwing an exception.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
        <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the list.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] TakeWhile&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] TakeWhile&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("takeWhile")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
        <param name="array">The input array.</param>
        <summary>Returns an array that contains all elements of the original array while the 
 given predicate returns True, and then returns no further elements.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; ToList&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; ToList&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ToList``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("toList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Builds a list from the given array.</summary>
        <returns>The list of array elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSeq&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; ToSeq&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; ToSeq&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ToSeq``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("toSeq")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Views the given array as a sequence.</summary>
        <returns>The sequence of array elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Truncate&lt;T&gt; (int count, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Truncate&lt;T&gt;(int32 count, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Truncate``1(System.Int32,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("truncate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The maximum number of items to return.</param>
        <param name="array">The input array.</param>
        <summary>Returns at most N elements in a new array.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFind&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryFind&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryFind&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFind")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the first element for which the given function returns True.
 Return None if no such element exists.</summary>
        <returns>The first element that satisfies the predicate, or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFindBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryFindBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryFindBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryFindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the last element for which the given function returns True.
 Return None if no such element exists.</summary>
        <returns>The last element that satisfies the predicate, or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;int&gt; TryFindIndex&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; TryFindIndex&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindIndex")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the index of the first element in the array
 that satisfies the given predicate.</summary>
        <returns>The index of the first element that satisfies the predicate, or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFindIndexBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;int&gt; TryFindIndexBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; TryFindIndexBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryFindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindIndexBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the index of the last element in the array
 that satisfies the given predicate.</summary>
        <returns>The index of the last element that satisfies the predicate, or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryHead&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryHead&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryHead&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryHead``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryHead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the first element of the array, or
 <c>None</c> if the array is empty.</summary>
        <returns>The first element of the array or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryItem&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryItem&lt;T&gt; (int index, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryItem&lt;T&gt;(int32 index, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryItem``1(System.Int32,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryItem")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index of element to retrieve.</param>
        <param name="array">To be added.</param>
        <summary>Tries to find the nth element in the array.
 Returns <c>None</c> if index is negative or the input array does not contain enough elements.</summary>
        <returns>The nth element of the array or <c>None</c>.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryLast&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryLast&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryLast``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryLast")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the last element of the array.
 Return <c>None</c> if no such element exists.</summary>
        <returns>The last element of the array or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryPick&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt; TryPick&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt; TryPick&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryPick")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">The function to transform the array elements into options.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>None</c> is returned.</summary>
        <returns>The first transformed element that is <c>Some(x)</c>.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unfold&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static T[] Unfold&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpOption&lt;Tuple&lt;T,TState&gt;&gt;&gt; generator, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Unfold&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpOption`1&lt;class System.Tuple`2&lt;!!T, !!TState&gt;&gt;&gt; generator, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unfold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="generator" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpOption&lt;System.Tuple&lt;T,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="generator">A function that takes in the current state and returns an option tuple of the next
 element of the array and the next state value.</param>
        <param name="state">The initial state value.</param>
        <summary>Returns an array that contains the elements generated by the given computation.
 The given initial <c>state</c> argument is passed to the element generator.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unzip&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1[],T2[]&gt; Unzip&lt;T1,T2&gt; (Tuple&lt;T1,T2&gt;[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T1[], !!T2[]&gt; Unzip&lt;T1, T2&gt;(class System.Tuple`2&lt;!!T1, !!T2&gt;[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Unzip``2(System.Tuple{``0,``1}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unzip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1[],T2[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="System.Tuple&lt;T1,T2&gt;[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Splits an array of pairs into two arrays.</summary>
        <returns>The two arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unzip3&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1[],T2[],T3[]&gt; Unzip3&lt;T1,T2,T3&gt; (Tuple&lt;T1,T2,T3&gt;[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`3&lt;!!T1[], !!T2[], !!T3[]&gt; Unzip3&lt;T1, T2, T3&gt;(class System.Tuple`3&lt;!!T1, !!T2, !!T3&gt;[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Unzip3``3(System.Tuple{``0,``1,``2}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unzip3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1[],T2[],T3[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="System.Tuple&lt;T1,T2,T3&gt;[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Splits an array of triples into three arrays.</summary>
        <returns>The tuple of three arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Where&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Where&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Where``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("where")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns a new array containing only the elements of the array
 for which the given predicate returns "true".</summary>
        <returns>An array containing the elements for which the given predicate returns true.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Windowed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[][] Windowed&lt;T&gt; (int windowSize, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[][] Windowed&lt;T&gt;(int32 windowSize, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Windowed``1(System.Int32,``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("windowed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[][]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="windowSize" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="windowSize">The number of elements in each window.</param>
        <param name="array">The input array.</param>
        <summary>Returns an array of sliding windows containing elements drawn from the input
 array. Each window is returned as a fresh array.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when windowSize is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="ZeroCreate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] ZeroCreate&lt;T&gt; (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] ZeroCreate&lt;T&gt;(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ZeroCreate``1(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zeroCreate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The length of the array to create.</param>
        <summary>Creates an array where the entries are initially the default value Unchecked.defaultof&lt;'T&gt;.</summary>
        <returns>The created array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1,T2&gt;[] Zip&lt;T1,T2&gt; (T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T1, !!T2&gt;[] Zip&lt;T1, T2&gt;(!!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Zip``2(``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1,T2&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Combines the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of tupled elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip3&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1,T2,T3&gt;[] Zip3&lt;T1,T2,T3&gt; (T1[] array1, T2[] array2, T3[] array3);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`3&lt;!!T1, !!T2, !!T3&gt;[] Zip3&lt;T1, T2, T3&gt;(!!T1[] array1, !!T2[] array2, !!T3[] array3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Zip3``3(``0[],``1[],``2[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zip3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1,T2,T3&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
        <Parameter Name="array3" Type="T3[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <param name="array3">The third input array.</param>
        <summary>Combines three arrays into an array of pairs. The three arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of tupled elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when any of the input arrays are null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
