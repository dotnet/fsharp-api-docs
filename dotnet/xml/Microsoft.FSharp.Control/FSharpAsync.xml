<Type Name="FSharpAsync" FullName="Microsoft.FSharp.Control.FSharpAsync">
  <TypeSignature Language="C#" Value="public sealed class FSharpAsync" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed FSharpAsync extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Control.FSharpAsync" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.4.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.ObjectType)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompiledName("FSharpAsync")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.Sealed</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>This static class holds members for creating and manipulating asynchronous computations.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsBeginEnd&lt;TArg,T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;TArg,AsyncCallback,object&gt;,IAsyncResult&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,Microsoft.FSharp.Core.Unit&gt;&gt; AsBeginEnd&lt;TArg,T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TArg,Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt; computation);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`3&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`3&lt;!!TArg, class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt;, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt;, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, class Microsoft.FSharp.Core.Unit&gt;&gt; AsBeginEnd&lt;TArg, T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TArg, class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt;&gt; computation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AsBeginEnd``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;TArg,System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,Microsoft.FSharp.Core.Unit&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg" />
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TArg,Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TArg">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">A function generating the asynchronous computation to split into the traditional
 .NET Asynchronous Programming Model.</param>
        <summary>Creates three functions that can be used to implement the .NET Asynchronous 
 Programming Model (APM) for a given asynchronous computation.</summary>
        <returns>A tuple of the begin, end, and cancel members.</returns>
        <remarks>The functions should normally be published as members with prefix <c>Begin</c>,
 <c>End</c> and <c>Cancel</c>, and can be used within a type definition as follows:
 <c>
   let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun arg -&gt; computation)
   member x.BeginSomeOperation(arg,callback,state:obj) = beginAction(arg,callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 </c>

 If the asynchronous computation takes no arguments, then AsBeginEnd is used as follows:
 <c>
   let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun () -&gt; computation)
   member x.BeginSomeOperation(callback,state:obj) = beginAction((),callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 </c>


 If the asynchronous computation takes two arguments, then AsBeginEnd is used as follows:
 <c>
   let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun arg1 arg2 -&gt; computation)
   member x.BeginSomeOperation(arg1,arg2,callback,state:obj) = beginAction((),callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 </c>

 In each case, the resulting API will be familiar to programmers in other CLI languages and 
 is a useful way to publish asynchronous computations in CLI components.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitEvent&lt;TDel,T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; AwaitEvent&lt;TDel,T&gt; (Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; event, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; AwaitEvent&lt;(class System.Delegate) TDel, T&gt;(class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; event, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitEvent``2(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="event" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDel">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="event">The event to handle once.</param>
        <param name="cancelAction">An optional function to execute instead of cancelling when a
 cancellation is issued.</param>
        <summary>Creates an asynchronous computation that waits for a single invocation of a CLI 
 event by adding a handler to the event. Once the computation completes or is 
 cancelled, the handler is removed from the event.</summary>
        <returns>An asynchronous computation that waits for the event to be invoked.</returns>
        <remarks>The computation will respond to cancellation while waiting for the event. If a 
 cancellation occurs, and <c>cancelAction</c> is specified, then it is executed, and 
 the computation continues to wait for the event.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to cancel immediately.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitIAsyncResult">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;bool&gt; AwaitIAsyncResult (IAsyncResult iar, Microsoft.FSharp.Core.FSharpOption&lt;int&gt; millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;bool&gt; AwaitIAsyncResult(class System.IAsyncResult iar, class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitIAsyncResult(System.IAsyncResult,Microsoft.FSharp.Core.FSharpOption{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iar" Type="System.IAsyncResult" />
        <Parameter Name="millisecondsTimeout" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="iar">The IAsyncResult to wait on.</param>
        <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <c>System.Threading.Timeout.Infinite</c>.</param>
        <summary>Creates an asynchronous computation that will wait on the IAsyncResult.</summary>
        <returns>An asynchronous computation that waits on the given <c>IAsyncResult</c>.</returns>
        <remarks>The computation returns true if the handle indicated a result within the given timeout.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitTask">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; AwaitTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; AwaitTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitTask(System.Threading.Tasks.Task)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">To be added.</param>
        <summary>
 Return an asynchronous computation that will wait for the given task to complete and return
 its result.
</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitTask&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; AwaitTask&lt;T&gt; (System.Threading.Tasks.Task&lt;T&gt; task);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; AwaitTask&lt;T&gt;(class System.Threading.Tasks.Task`1&lt;!!T&gt; task) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitTask``1(System.Threading.Tasks.Task{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="task">To be added.</param>
        <summary>
 Return an asynchronous computation that will wait for the given task to complete and return
 its result.
</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitWaitHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;bool&gt; AwaitWaitHandle (System.Threading.WaitHandle waitHandle, Microsoft.FSharp.Core.FSharpOption&lt;int&gt; millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;bool&gt; AwaitWaitHandle(class System.Threading.WaitHandle waitHandle, class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitWaitHandle(System.Threading.WaitHandle,Microsoft.FSharp.Core.FSharpOption{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandle" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="waitHandle">The <c>WaitHandle</c> that can be signalled.</param>
        <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <c>System.Threading.Timeout.Infinite</c>.</param>
        <summary>Creates an asynchronous computation that will wait on the given WaitHandle.</summary>
        <returns>An asynchronous computation that waits on the given <c>WaitHandle</c>.</returns>
        <remarks>The computation returns true if the handle indicated a result within the given timeout.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelDefaultToken">
      <MemberSignature Language="C#" Value="public static void CancelDefaultToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void CancelDefaultToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.CancelDefaultToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the cancellation condition for the most recent set of asynchronous computations started 
 without any specific CancellationToken. Replaces the global CancellationTokenSource with a new 
 global token source for any asynchronous computations created after this point without any 
 specific CancellationToken.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;System.Threading.CancellationToken&gt; CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.FSharp.Control.FSharpAsync`1&lt;valuetype System.Threading.CancellationToken&gt; CancellationToken" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Control.FSharpAsync.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.Threading.CancellationToken&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Creates an asynchronous computation that returns the CancellationToken governing the execution 
 of the computation.</summary>
        <value>An asynchronous computation capable of retrieving the CancellationToken from a computation
 expression.</value>
        <remarks>In <c>async { let! token = Async.CancellationToken ...}</c> token can be used to initiate other 
 asynchronous operations that will cancel cooperatively with this workflow.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpChoice&lt;T,Exception&gt;&gt; Catch&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.FSharpChoice`2&lt;!!T, class System.Exception&gt;&gt; Catch&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Catch``1(Microsoft.FSharp.Control.FSharpAsync{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpChoice&lt;T,System.Exception&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The input computation that returns the type T.</param>
        <summary>Creates an asynchronous computation that executes <c>computation</c>.
 If this computation completes successfully then return <c>Choice1Of2</c> with the returned
 value. If this computation raises an exception before it completes then return <c>Choice2Of2</c>
 with the raised exception.</summary>
        <returns>A computation that returns a choice of type T or exception.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Choice&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpOption&lt;T&gt;&gt; Choice&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpOption&lt;T&gt;&gt;&gt; computations);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt;&gt; Choice&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt;&gt;&gt; computations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Choice``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpOption&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computations" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpOption&lt;T&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computations">A sequence of computations to be parallelized.</param>
        <summary>Creates an asynchronous computation that executes all given asynchronous computations in parallel, 
 returning the result of the first succeeding computation (one whose result is 'Some x').
 If all child computations complete with None, the parent computation also returns None.</summary>
        <returns>A computation that returns the first succeeding computation.</returns>
        <remarks>
 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCancellationToken">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationToken DefaultCancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Threading.CancellationToken DefaultCancellationToken" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Control.FSharpAsync.DefaultCancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default cancellation token for executing asynchronous computations.</summary>
        <value>The default CancellationToken.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBeginEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromBeginEnd&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;AsyncCallback,object&gt;,IAsyncResult&gt; beginAction, Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt; endAction, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromBeginEnd&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`2&lt;class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt; beginAction, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt; endAction, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;" />
        <Parameter Name="endAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
        <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
        <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
        <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. For example, 
     <c>Async.FromBeginEnd(ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>
        <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
        <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBeginEnd&lt;TArg1,T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromBeginEnd&lt;TArg1,T&gt; (TArg1 arg, Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;TArg1,AsyncCallback,object&gt;,IAsyncResult&gt; beginAction, Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt; endAction, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromBeginEnd&lt;TArg1, T&gt;(!!TArg1 arg, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`3&lt;!!TArg1, class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt; beginAction, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt; endAction, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``2(``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg" Type="TArg1" />
        <Parameter Name="beginAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;TArg1,System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;" />
        <Parameter Name="endAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TArg1">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="arg">The argument for the operation.</param>
        <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
        <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
        <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
        <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overload should be used if the operation is 
 qualified by one argument. For example, 
     <c>Async.FromBeginEnd(place,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>
        <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
        <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBeginEnd&lt;TArg1,TArg2,T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromBeginEnd&lt;TArg1,TArg2,T&gt; (TArg1 arg1, TArg2 arg2, Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;TArg1,TArg2,AsyncCallback,object&gt;,IAsyncResult&gt; beginAction, Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt; endAction, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromBeginEnd&lt;TArg1, TArg2, T&gt;(!!TArg1 arg1, !!TArg2 arg2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`4&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt; beginAction, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt; endAction, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="beginAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;TArg1,TArg2,System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;" />
        <Parameter Name="endAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TArg1">To be added.</typeparam>
        <typeparam name="TArg2">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="arg1">The first argument for the operation.</param>
        <param name="arg2">The second argument for the operation.</param>
        <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
        <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
        <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
        <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overload should be used if the operation is 
 qualified by two arguments. For example, 
     <c>Async.FromBeginEnd(arg1,arg2,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>
        <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
        <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBeginEnd&lt;TArg1,TArg2,TArg3,T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromBeginEnd&lt;TArg1,TArg2,TArg3,T&gt; (TArg1 arg1, TArg2 arg2, TArg3 arg3, Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;TArg1,TArg2,TArg3,AsyncCallback,object&gt;,IAsyncResult&gt; beginAction, Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt; endAction, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromBeginEnd&lt;TArg1, TArg2, TArg3, T&gt;(!!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`5&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt; beginAction, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt; endAction, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``3},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="beginAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;" />
        <Parameter Name="endAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TArg1">To be added.</typeparam>
        <typeparam name="TArg2">To be added.</typeparam>
        <typeparam name="TArg3">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="arg1">The first argument for the operation.</param>
        <param name="arg2">The second argument for the operation.</param>
        <param name="arg3">The third argument for the operation.</param>
        <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
        <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
        <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
        <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overload should be used if the operation is 
 qualified by three arguments. For example, 
     <c>Async.FromBeginEnd(arg1,arg2,arg3,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>
        <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
        <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromContinuations&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromContinuations&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;Exception,Microsoft.FSharp.Core.Unit&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;OperationCanceledException,Microsoft.FSharp.Core.Unit&gt;&gt;,Microsoft.FSharp.Core.Unit&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromContinuations&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`3&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt;, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Exception, class Microsoft.FSharp.Core.Unit&gt;, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.OperationCanceledException, class Microsoft.FSharp.Core.Unit&gt;&gt;, class Microsoft.FSharp.Core.Unit&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromContinuations``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;System.Exception,Microsoft.FSharp.Core.Unit&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;System.OperationCanceledException,Microsoft.FSharp.Core.Unit&gt;&gt;,Microsoft.FSharp.Core.Unit&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="callback">The function that accepts the current success, exception, and cancellation
 continuations.</param>
        <summary>Creates an asynchronous computation that captures the current
 success, exception and cancellation continuations. The callback must 
 eventually call exactly one of the given continuations.</summary>
        <returns>An asynchronous computation that provides the callback with the current continuations.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; Ignore&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; Ignore&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Ignore``1(Microsoft.FSharp.Control.FSharpAsync{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The input computation.</param>
        <summary>Creates an asynchronous computation that runs the given computation and ignores 
 its result.</summary>
        <returns>A computation that is equivalent to the input computation, but disregards the result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCancel">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;IDisposable&gt; OnCancel (Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt; interruption);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class System.IDisposable&gt; OnCancel(class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt; interruption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.OnCancel(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.IDisposable&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interruption" Type="Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;" />
      </Parameters>
      <Docs>
        <param name="interruption">The function that is executed on the thread performing the
 cancellation.</param>
        <summary>Generates a scoped, cooperative cancellation handler for use within an asynchronous workflow.</summary>
        <returns>An asynchronous computation that triggers the interruption if it is cancelled
 before being disposed.</returns>
        <remarks>For example,
     <c>async { use! holder = Async.OnCancel interruption ... }</c> 
 generates an asynchronous computation where, if a cancellation happens any time during 
 the execution of the asynchronous computation in the scope of <c>holder</c>, then action 
 <c>interruption</c> is executed on the thread that is performing the cancellation. This can 
 be used to arrange for a computation to be asynchronously notified that a cancellation 
 has occurred, e.g. by setting a flag, or deregistering a pending I/O action.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parallel&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T[]&gt; Parallel&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt; computations);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T[]&gt; Parallel&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt;&gt; computations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computations" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computations">A sequence of distinct computations to be parallelized.</param>
        <summary>Creates an asynchronous computation that executes all the given asynchronous computations, 
 initially queueing each as work items and using a fork/join pattern.</summary>
        <returns>A computation that returns an array of values from the sequence of input computations.</returns>
        <remarks>If all child computations succeed, an array of results is passed to the success continuation.
 
 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T RunSynchronously&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;int&gt; timeout, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T RunSynchronously&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; timeout, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.RunSynchronously``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="timeout" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The computation to run.</param>
        <param name="timeout">The amount of time in milliseconds to wait for the result of the
 computation before raising a <c>System.TimeoutException</c>.  If no value is provided
 for timeout then a default of -1 is used to correspond to System.Threading.Timeout.Infinite.</param>
        <param name="cancellationToken">The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</param>
        <summary>Runs the asynchronous computation and await its result.</summary>
        <returns>The result of the computation.</returns>
        <remarks>If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.
        
 If no cancellation token is provided then the default cancellation token is used.

 The timeout parameter is given in milliseconds.  A value of -1 is equivalent to
 System.Threading.Timeout.Infinite.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; Sleep (int millisecondsDueTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; Sleep(int32 millisecondsDueTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Sleep(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDueTime" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDueTime">The number of milliseconds to sleep.</param>
        <summary>Creates an asynchronous computation that will sleep for the given time. This is scheduled
 using a System.Threading.Timer object. The operation will not block operating system threads
 for the duration of the wait.</summary>
        <returns>An asynchronous computation that will sleep for the given time.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentOutOfRangeException">Thrown when the due time is negative
 and not infinite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static void Start (Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Start(class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Start(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="computation">The computation to run asynchronously.</param>
        <param name="cancellationToken">The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</param>
        <summary>Starts the asynchronous computation in the thread pool. Do not await its result.</summary>
        <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartAsTask&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;T&gt; StartAsTask&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.Tasks.TaskCreationOptions&gt; taskCreationOptions, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Threading.Tasks.Task`1&lt;!!T&gt; StartAsTask&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.Tasks.TaskCreationOptions&gt; taskCreationOptions, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="taskCreationOptions" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.Tasks.TaskCreationOptions&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">To be added.</param>
        <param name="taskCreationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>Executes a computation in the thread pool.</summary>
        <returns>A <c>System.Threading.Tasks.Task</c> that will be completed
 in the corresponding state once the computation terminates (produces the result, throws exception or gets canceled)</returns>
        <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartChild&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt; StartChild&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;int&gt; millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt;&gt; StartChild&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartChild``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="millisecondsTimeout" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The child computation.</param>
        <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <c>System.Threading.Timeout.Infinite</c>.</param>
        <summary>Starts a child computation within an asynchronous workflow. 
 This allows multiple asynchronous computations to be executed simultaneously.</summary>
        <returns>A new computation that waits for the input computation to finish.</returns>
        <remarks>This method should normally be used as the immediate 
 right-hand-side of a <c>let!</c> binding in an F# asynchronous workflow, that is,
 
        async { ...
                let! completor1 = childComputation1 |&gt; Async.StartChild  
                let! completor2 = childComputation2 |&gt; Async.StartChild  
                ... 
                let! result1 = completor1 
                let! result2 = completor2 
                ... }
 
 When used in this way, each use of <c>StartChild</c> starts an instance of <c>childComputation</c> 
 and returns a completor object representing a computation to wait for the completion of the operation.
 When executed, the completor awaits the completion of <c>childComputation</c>.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartChildAsTask&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;System.Threading.Tasks.Task&lt;T&gt;&gt; StartChildAsTask&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.Tasks.TaskCreationOptions&gt; taskCreationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class System.Threading.Tasks.Task`1&lt;!!T&gt;&gt; StartChildAsTask&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.Tasks.TaskCreationOptions&gt; taskCreationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartChildAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.Threading.Tasks.Task&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="taskCreationOptions" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.Tasks.TaskCreationOptions&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">To be added.</param>
        <param name="taskCreationOptions">To be added.</param>
        <summary>Creates an asynchronous computation which starts the given computation as a <c>System.Threading.Tasks.Task</c></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartImmediate">
      <MemberSignature Language="C#" Value="public static void StartImmediate (Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static void StartImmediate(class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartImmediate(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="computation">The asynchronous computation to execute.</param>
        <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>
        <summary>Runs an asynchronous computation, starting immediately on the current operating system
 thread.</summary>
        <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartWithContinuations&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StartWithContinuations&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt; continuation, Microsoft.FSharp.Core.FSharpFunc&lt;Exception,Microsoft.FSharp.Core.Unit&gt; exceptionContinuation, Microsoft.FSharp.Core.FSharpFunc&lt;OperationCanceledException,Microsoft.FSharp.Core.Unit&gt; cancellationContinuation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static void StartWithContinuations&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt; continuation, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Exception, class Microsoft.FSharp.Core.Unit&gt; exceptionContinuation, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.OperationCanceledException, class Microsoft.FSharp.Core.Unit&gt; cancellationContinuation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartWithContinuations``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="continuation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="exceptionContinuation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Exception,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="cancellationContinuation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.OperationCanceledException,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The asynchronous computation to execute.</param>
        <param name="continuation">The function called on success.</param>
        <param name="exceptionContinuation">The function called on exception.</param>
        <param name="cancellationContinuation">The function called on cancellation.</param>
        <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>
        <summary>Runs an asynchronous computation, starting immediately on the current operating system
 thread. Call one of the three continuations when the operation completes.</summary>
        <remarks>If no cancellation token is provided then the default cancellation token
 is used.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchToContext">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; SwitchToContext (System.Threading.SynchronizationContext syncContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; SwitchToContext(class System.Threading.SynchronizationContext syncContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToContext(System.Threading.SynchronizationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syncContext" Type="System.Threading.SynchronizationContext" />
      </Parameters>
      <Docs>
        <param name="syncContext">The synchronization context to accept the posted computation.</param>
        <summary>Creates an asynchronous computation that runs
 its continuation using syncContext.Post. If syncContext is null 
 then the asynchronous computation is equivalent to SwitchToThreadPool().</summary>
        <returns>An asynchronous computation that uses the syncContext context to execute.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchToNewThread">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; SwitchToNewThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; SwitchToNewThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToNewThread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an asynchronous computation that creates a new thread and runs
 its continuation in that thread.</summary>
        <returns>A computation that will execute on a new thread.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchToThreadPool">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; SwitchToThreadPool ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; SwitchToThreadPool() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToThreadPool" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an asynchronous computation that queues a work item that runs
 its continuation.</summary>
        <returns>A computation that generates a new work item in the thread pool.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCancelled&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; TryCancelled&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpFunc&lt;OperationCanceledException,Microsoft.FSharp.Core.Unit&gt; compensation);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; TryCancelled&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.OperationCanceledException, class Microsoft.FSharp.Core.Unit&gt; compensation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.TryCancelled``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="compensation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.OperationCanceledException,Microsoft.FSharp.Core.Unit&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The input asynchronous computation.</param>
        <param name="compensation">The function to be run if the computation is cancelled.</param>
        <summary>Creates an asynchronous computation that executes <c>computation</c>.
 If this computation is cancelled before it completes then the computation generated by 
 running <c>compensation</c> is executed.</summary>
        <returns>An asynchronous computation that runs the compensation if the input computation
 is cancelled.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
