<Type Name="FSharpAsync" FullName="Microsoft.FSharp.Control.FSharpAsync">
  <TypeSignature Language="C#" Value="public sealed class FSharpAsync" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed FSharpAsync extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Control.FSharpAsync" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FSharpAsync" />
  <TypeSignature Language="F#" Value="type Async = class" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.ObjectType)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompiledName("FSharpAsync")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.Sealed</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>This static class holds members for creating and manipulating asynchronous computations.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsBeginEnd&lt;TArg,T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;TArg,AsyncCallback,object&gt;,IAsyncResult&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,Microsoft.FSharp.Core.Unit&gt;&gt; AsBeginEnd&lt;TArg,T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TArg,Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt; computation);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`3&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`3&lt;!!TArg, class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt;, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt;, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, class Microsoft.FSharp.Core.Unit&gt;&gt; AsBeginEnd&lt;TArg, T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TArg, class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt;&gt; computation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AsBeginEnd``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsBeginEnd(Of TArg, T) (computation As FSharpFunc(Of TArg, FSharpAsync(Of T))) As Tuple(Of FSharpFunc(Of Tuple(Of TArg, AsyncCallback, Object), IAsyncResult), FSharpFunc(Of IAsyncResult, T), FSharpFunc(Of IAsyncResult, Unit))" />
      <MemberSignature Language="F#" Value="static member AsBeginEnd : ('Arg -&gt; Async&lt;'T&gt;) -&gt; ('Arg * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; 'T) * (IAsyncResult -&gt; unit)" Usage="Microsoft.FSharp.Control.Async.AsBeginEnd computation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;TArg,System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,Microsoft.FSharp.Core.Unit&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg" />
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TArg,Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TArg">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">A function generating the asynchronous computation to split into the traditional
 .NET Asynchronous Programming Model.</param>
        <summary>Creates three functions that can be used to implement the .NET Asynchronous 
 Programming Model (APM) for a given asynchronous computation.</summary>
        <returns>A tuple of the begin, end, and cancel members.</returns>
        <remarks>The functions should normally be published as members with prefix <c>Begin</c>,
 <c>End</c> and <c>Cancel</c>, and can be used within a type definition as follows:
 <c>
   let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun arg -&gt; computation)
   member x.BeginSomeOperation(arg,callback,state:obj) = beginAction(arg,callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 </c>

 If the asynchronous computation takes no arguments, then AsBeginEnd is used as follows:
 <c>
   let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun () -&gt; computation)
   member x.BeginSomeOperation(callback,state:obj) = beginAction((),callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 </c>


 If the asynchronous computation takes two arguments, then AsBeginEnd is used as follows:
 <c>
   let beginAction,endAction,cancelAction = Async.AsBeginEnd (fun arg1 arg2 -&gt; computation)
   member x.BeginSomeOperation(arg1,arg2,callback,state:obj) = beginAction((),callback,state)
   member x.EndSomeOperation(iar) = endAction(iar)
   member x.CancelSomeOperation(iar) = cancelAction(iar)
 </c>

 In each case, the resulting API will be familiar to programmers in other CLI languages and 
 is a useful way to publish asynchronous computations in CLI components.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitEvent&lt;TDel,T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; AwaitEvent&lt;TDel,T&gt; (Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; event, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; AwaitEvent&lt;(class System.Delegate) TDel, T&gt;(class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; event, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitEvent``2(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AwaitEvent(Of TDel As Delegate, T As Delegate) (event As IEvent(Of TDel, T), cancelAction As FSharpOption(Of FSharpFunc(Of Unit, Unit))) As FSharpAsync(Of T)" />
      <MemberSignature Language="F#" Value="static member AwaitEvent : Microsoft.FSharp.Control.IEvent&lt;'Del, 'T (requires 'Del :&gt; Delegate)&gt; * option&lt;unit -&gt; unit&gt; -&gt; Async&lt;'T&gt; (requires 'Del :&gt; Delegate)" Usage="Microsoft.FSharp.Control.Async.AwaitEvent (event, cancelAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="event" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDel">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="event">The event to handle once.</param>
        <param name="cancelAction">An optional function to execute instead of cancelling when a
 cancellation is issued.</param>
        <summary>Creates an asynchronous computation that waits for a single invocation of a CLI 
 event by adding a handler to the event. Once the computation completes or is 
 cancelled, the handler is removed from the event.</summary>
        <returns>An asynchronous computation that waits for the event to be invoked.</returns>
        <remarks>The computation will respond to cancellation while waiting for the event. If a 
 cancellation occurs, and <c>cancelAction</c> is specified, then it is executed, and 
 the computation continues to wait for the event.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to cancel immediately.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitIAsyncResult">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;bool&gt; AwaitIAsyncResult (IAsyncResult iar, Microsoft.FSharp.Core.FSharpOption&lt;int&gt; millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;bool&gt; AwaitIAsyncResult(class System.IAsyncResult iar, class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitIAsyncResult(System.IAsyncResult,Microsoft.FSharp.Core.FSharpOption{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AwaitIAsyncResult (iar As IAsyncResult, millisecondsTimeout As FSharpOption(Of Integer)) As FSharpAsync(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member AwaitIAsyncResult : IAsyncResult * option&lt;int&gt; -&gt; Async&lt;bool&gt;" Usage="Microsoft.FSharp.Control.Async.AwaitIAsyncResult (iar, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iar" Type="System.IAsyncResult" />
        <Parameter Name="millisecondsTimeout" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="iar">The IAsyncResult to wait on.</param>
        <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <c>System.Threading.Timeout.Infinite</c>.</param>
        <summary>Creates an asynchronous computation that will wait on the IAsyncResult.</summary>
        <returns>An asynchronous computation that waits on the given <c>IAsyncResult</c>.</returns>
        <remarks>The computation returns true if the handle indicated a result within the given timeout.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitTask">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; AwaitTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; AwaitTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="F#" Value="static member AwaitTask : System.Threading.Tasks.Task -&gt; Async&lt;unit&gt;" Usage="Microsoft.FSharp.Control.Async.AwaitTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">To be added.</param>
        <summary>
 Return an asynchronous computation that will wait for the given task to complete and return
 its result.
</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitTask&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; AwaitTask&lt;T&gt; (System.Threading.Tasks.Task&lt;T&gt; task);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; AwaitTask&lt;T&gt;(class System.Threading.Tasks.Task`1&lt;!!T&gt; task) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitTask``1(System.Threading.Tasks.Task{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AwaitTask(Of T) (task As Task(Of T)) As FSharpAsync(Of T)" />
      <MemberSignature Language="F#" Value="static member AwaitTask : System.Threading.Tasks.Task&lt;'T&gt; -&gt; Async&lt;'T&gt;" Usage="Microsoft.FSharp.Control.Async.AwaitTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="task">To be added.</param>
        <summary>
 Return an asynchronous computation that will wait for the given task to complete and return
 its result.
</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitWaitHandle">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;bool&gt; AwaitWaitHandle (System.Threading.WaitHandle waitHandle, Microsoft.FSharp.Core.FSharpOption&lt;int&gt; millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;bool&gt; AwaitWaitHandle(class System.Threading.WaitHandle waitHandle, class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.AwaitWaitHandle(System.Threading.WaitHandle,Microsoft.FSharp.Core.FSharpOption{System.Int32})" />
      <MemberSignature Language="F#" Value="static member AwaitWaitHandle : System.Threading.WaitHandle * option&lt;int&gt; -&gt; Async&lt;bool&gt;" Usage="Microsoft.FSharp.Control.Async.AwaitWaitHandle (waitHandle, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandle" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="waitHandle">The <c>WaitHandle</c> that can be signalled.</param>
        <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <c>System.Threading.Timeout.Infinite</c>.</param>
        <summary>Creates an asynchronous computation that will wait on the given WaitHandle.</summary>
        <returns>An asynchronous computation that waits on the given <c>WaitHandle</c>.</returns>
        <remarks>The computation returns true if the handle indicated a result within the given timeout.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelDefaultToken">
      <MemberSignature Language="C#" Value="public static void CancelDefaultToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void CancelDefaultToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.CancelDefaultToken" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelDefaultToken ()" />
      <MemberSignature Language="F#" Value="static member CancelDefaultToken : unit -&gt; unit" Usage="Microsoft.FSharp.Control.Async.CancelDefaultToken " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the cancellation condition for the most recent set of asynchronous computations started 
 without any specific CancellationToken. Replaces the global CancellationTokenSource with a new 
 global token source for any asynchronous computations created after this point without any 
 specific CancellationToken.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;System.Threading.CancellationToken&gt; CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.FSharp.Control.FSharpAsync`1&lt;valuetype System.Threading.CancellationToken&gt; CancellationToken" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Control.FSharpAsync.CancellationToken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CancellationToken As FSharpAsync(Of CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.CancellationToken : Async&lt;System.Threading.CancellationToken&gt;" Usage="Microsoft.FSharp.Control.Async.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.Threading.CancellationToken&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Creates an asynchronous computation that returns the CancellationToken governing the execution 
 of the computation.</summary>
        <value>An asynchronous computation capable of retrieving the CancellationToken from a computation
 expression.</value>
        <remarks>In <c>async { let! token = Async.CancellationToken ...}</c> token can be used to initiate other 
 asynchronous operations that will cancel cooperatively with this workflow.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Catch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpChoice&lt;T,Exception&gt;&gt; Catch&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.FSharpChoice`2&lt;!!T, class System.Exception&gt;&gt; Catch&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Catch``1(Microsoft.FSharp.Control.FSharpAsync{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Catch(Of T) (computation As FSharpAsync(Of T)) As FSharpAsync(Of FSharpChoice(Of T, Exception))" />
      <MemberSignature Language="F#" Value="static member Catch : Async&lt;'T&gt; -&gt; Async&lt;Choice&lt;'T, Exception&gt;&gt;" Usage="Microsoft.FSharp.Control.Async.Catch computation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpChoice&lt;T,System.Exception&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The input computation that returns the type T.</param>
        <summary>Creates an asynchronous computation that executes <c>computation</c>.
 If this computation completes successfully then return <c>Choice1Of2</c> with the returned
 value. If this computation raises an exception before it completes then return <c>Choice2Of2</c>
 with the raised exception.</summary>
        <returns>A computation that returns a choice of type T or exception.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Choice&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpOption&lt;T&gt;&gt; Choice&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpOption&lt;T&gt;&gt;&gt; computations);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt;&gt; Choice&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt;&gt;&gt; computations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Choice``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpOption{``0}}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Choice(Of T) (computations As IEnumerable(Of FSharpAsync(Of FSharpOption(Of T)))) As FSharpAsync(Of FSharpOption(Of T))" />
      <MemberSignature Language="F#" Value="static member Choice : seq&lt;Async&lt;option&lt;'T&gt;&gt;&gt; -&gt; Async&lt;option&lt;'T&gt;&gt;" Usage="Microsoft.FSharp.Control.Async.Choice computations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpOption&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computations" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.FSharpOption&lt;T&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computations">A sequence of computations to be parallelized.</param>
        <summary>Creates an asynchronous computation that executes all given asynchronous computations in parallel, 
 returning the result of the first succeeding computation (one whose result is 'Some x').
 If all child computations complete with None, the parent computation also returns None.</summary>
        <returns>A computation that returns the first succeeding computation.</returns>
        <remarks>
 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCancellationToken">
      <MemberSignature Language="C#" Value="public static System.Threading.CancellationToken DefaultCancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Threading.CancellationToken DefaultCancellationToken" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Control.FSharpAsync.DefaultCancellationToken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultCancellationToken As CancellationToken" />
      <MemberSignature Language="F#" Value="member this.DefaultCancellationToken : System.Threading.CancellationToken" Usage="Microsoft.FSharp.Control.Async.DefaultCancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default cancellation token for executing asynchronous computations.</summary>
        <value>The default CancellationToken.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBeginEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromBeginEnd&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;AsyncCallback,object&gt;,IAsyncResult&gt; beginAction, Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt; endAction, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromBeginEnd&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`2&lt;class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt; beginAction, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt; endAction, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromBeginEnd(Of T) (beginAction As FSharpFunc(Of Tuple(Of AsyncCallback, Object), IAsyncResult), endAction As FSharpFunc(Of IAsyncResult, T), cancelAction As FSharpOption(Of FSharpFunc(Of Unit, Unit))) As FSharpAsync(Of T)" />
      <MemberSignature Language="F#" Value="static member FromBeginEnd : (AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; 'T) * option&lt;unit -&gt; unit&gt; -&gt; Async&lt;'T&gt;" Usage="Microsoft.FSharp.Control.Async.FromBeginEnd (beginAction, endAction, cancelAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;" />
        <Parameter Name="endAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
        <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
        <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
        <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. For example, 
     <c>Async.FromBeginEnd(ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>
        <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
        <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBeginEnd&lt;TArg1,T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromBeginEnd&lt;TArg1,T&gt; (TArg1 arg, Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;TArg1,AsyncCallback,object&gt;,IAsyncResult&gt; beginAction, Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt; endAction, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromBeginEnd&lt;TArg1, T&gt;(!!TArg1 arg, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`3&lt;!!TArg1, class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt; beginAction, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt; endAction, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``2(``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``1},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromBeginEnd(Of TArg1, T) (arg As TArg1, beginAction As FSharpFunc(Of Tuple(Of TArg1, AsyncCallback, Object), IAsyncResult), endAction As FSharpFunc(Of IAsyncResult, T), cancelAction As FSharpOption(Of FSharpFunc(Of Unit, Unit))) As FSharpAsync(Of T)" />
      <MemberSignature Language="F#" Value="static member FromBeginEnd : 'TArg1 * ('TArg1 * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; 'T) * option&lt;unit -&gt; unit&gt; -&gt; Async&lt;'T&gt;" Usage="Microsoft.FSharp.Control.Async.FromBeginEnd (arg, beginAction, endAction, cancelAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg" Type="TArg1" />
        <Parameter Name="beginAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;TArg1,System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;" />
        <Parameter Name="endAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TArg1">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="arg">The argument for the operation.</param>
        <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
        <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
        <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
        <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overload should be used if the operation is 
 qualified by one argument. For example, 
     <c>Async.FromBeginEnd(place,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>
        <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
        <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBeginEnd&lt;TArg1,TArg2,T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromBeginEnd&lt;TArg1,TArg2,T&gt; (TArg1 arg1, TArg2 arg2, Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;TArg1,TArg2,AsyncCallback,object&gt;,IAsyncResult&gt; beginAction, Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt; endAction, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromBeginEnd&lt;TArg1, TArg2, T&gt;(!!TArg1 arg1, !!TArg2 arg2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`4&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt; beginAction, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt; endAction, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``2},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromBeginEnd(Of TArg1, TArg2, T) (arg1 As TArg1, arg2 As TArg2, beginAction As FSharpFunc(Of Tuple(Of TArg1, TArg2, AsyncCallback, Object), IAsyncResult), endAction As FSharpFunc(Of IAsyncResult, T), cancelAction As FSharpOption(Of FSharpFunc(Of Unit, Unit))) As FSharpAsync(Of T)" />
      <MemberSignature Language="F#" Value="static member FromBeginEnd : 'TArg1 * 'TArg2 * ('TArg1 * 'TArg2 * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; 'T) * option&lt;unit -&gt; unit&gt; -&gt; Async&lt;'T&gt;" Usage="Microsoft.FSharp.Control.Async.FromBeginEnd (arg1, arg2, beginAction, endAction, cancelAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="beginAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;TArg1,TArg2,System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;" />
        <Parameter Name="endAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TArg1">To be added.</typeparam>
        <typeparam name="TArg2">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="arg1">The first argument for the operation.</param>
        <param name="arg2">The second argument for the operation.</param>
        <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
        <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
        <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
        <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overload should be used if the operation is 
 qualified by two arguments. For example, 
     <c>Async.FromBeginEnd(arg1,arg2,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>
        <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
        <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBeginEnd&lt;TArg1,TArg2,TArg3,T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromBeginEnd&lt;TArg1,TArg2,TArg3,T&gt; (TArg1 arg1, TArg2 arg2, TArg3 arg3, Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;TArg1,TArg2,TArg3,AsyncCallback,object&gt;,IAsyncResult&gt; beginAction, Microsoft.FSharp.Core.FSharpFunc&lt;IAsyncResult,T&gt; endAction, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromBeginEnd&lt;TArg1, TArg2, TArg3, T&gt;(!!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`5&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object&gt;, class System.IAsyncResult&gt; beginAction, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.IAsyncResult, !!T&gt; endAction, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt;&gt; cancelAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromBeginEnd``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2,System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``3},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromBeginEnd(Of TArg1, TArg2, TArg3, T) (arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, beginAction As FSharpFunc(Of Tuple(Of TArg1, TArg2, TArg3, AsyncCallback, Object), IAsyncResult), endAction As FSharpFunc(Of IAsyncResult, T), cancelAction As FSharpOption(Of FSharpFunc(Of Unit, Unit))) As FSharpAsync(Of T)" />
      <MemberSignature Language="F#" Value="static member FromBeginEnd : 'TArg1 * 'TArg2 * 'TArg3 * ('TArg1 * 'TArg2 * 'TArg3 * AsyncCallback * obj -&gt; IAsyncResult) * (IAsyncResult -&gt; 'T) * option&lt;unit -&gt; unit&gt; -&gt; Async&lt;'T&gt;" Usage="Microsoft.FSharp.Control.Async.FromBeginEnd (arg1, arg2, arg3, beginAction, endAction, cancelAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="beginAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object&gt;,System.IAsyncResult&gt;" />
        <Parameter Name="endAction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.IAsyncResult,T&gt;" />
        <Parameter Name="cancelAction" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TArg1">To be added.</typeparam>
        <typeparam name="TArg2">To be added.</typeparam>
        <typeparam name="TArg3">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="arg1">The first argument for the operation.</param>
        <param name="arg2">The second argument for the operation.</param>
        <param name="arg3">The third argument for the operation.</param>
        <param name="beginAction">The function initiating a traditional CLI asynchronous operation.</param>
        <param name="endAction">The function completing a traditional CLI asynchronous operation.</param>
        <param name="cancelAction">An optional function to be executed when a cancellation is requested.</param>
        <summary>Creates an asynchronous computation in terms of a Begin/End pair of actions in 
 the style used in CLI APIs. This overload should be used if the operation is 
 qualified by three arguments. For example, 
     <c>Async.FromBeginEnd(arg1,arg2,arg3,ws.BeginGetWeather,ws.EndGetWeather)</c>
 When the computation is run, <c>beginFunc</c> is executed, with
 a callback which represents the continuation of the computation. 
 When the callback is invoked, the overall result is fetched using <c>endFunc</c>.</summary>
        <returns>An asynchronous computation wrapping the given Begin/End functions.</returns>
        <remarks>The computation will respond to cancellation while waiting for the completion
 of the operation. If a cancellation occurs, and <c>cancelAction</c> is specified, then it is 
 executed, and the computation continues to wait for the completion of the operation.
 
 If <c>cancelAction</c> is not specified, then cancellation causes the computation
 to stop immediately, and subsequent invocations of the callback are ignored.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromContinuations&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; FromContinuations&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;Tuple&lt;Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;Exception,Microsoft.FSharp.Core.Unit&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;OperationCanceledException,Microsoft.FSharp.Core.Unit&gt;&gt;,Microsoft.FSharp.Core.Unit&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; FromContinuations&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Tuple`3&lt;class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt;, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Exception, class Microsoft.FSharp.Core.Unit&gt;, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.OperationCanceledException, class Microsoft.FSharp.Core.Unit&gt;&gt;, class Microsoft.FSharp.Core.Unit&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.FromContinuations``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.Unit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromContinuations(Of T) (callback As FSharpFunc(Of Tuple(Of FSharpFunc(Of T, Unit), FSharpFunc(Of Exception, Unit), FSharpFunc(Of OperationCanceledException, Unit)), Unit)) As FSharpAsync(Of T)" />
      <MemberSignature Language="F#" Value="static member FromContinuations : (('T -&gt; unit) * (Exception -&gt; unit) * (OperationCanceledException -&gt; unit) -&gt; unit) -&gt; Async&lt;'T&gt;" Usage="Microsoft.FSharp.Control.Async.FromContinuations callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Tuple&lt;Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;System.Exception,Microsoft.FSharp.Core.Unit&gt;,Microsoft.FSharp.Core.FSharpFunc&lt;System.OperationCanceledException,Microsoft.FSharp.Core.Unit&gt;&gt;,Microsoft.FSharp.Core.Unit&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="callback">The function that accepts the current success, exception, and cancellation
 continuations.</param>
        <summary>Creates an asynchronous computation that captures the current
 success, exception and cancellation continuations. The callback must 
 eventually call exactly one of the given continuations.</summary>
        <returns>An asynchronous computation that provides the callback with the current continuations.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; Ignore&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; Ignore&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Ignore``1(Microsoft.FSharp.Control.FSharpAsync{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ignore(Of T) (computation As FSharpAsync(Of T)) As FSharpAsync(Of Unit)" />
      <MemberSignature Language="F#" Value="static member Ignore : Async&lt;'T&gt; -&gt; Async&lt;unit&gt;" Usage="Microsoft.FSharp.Control.Async.Ignore computation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The input computation.</param>
        <summary>Creates an asynchronous computation that runs the given computation and ignores 
 its result.</summary>
        <returns>A computation that is equivalent to the input computation, but disregards the result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCancel">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;IDisposable&gt; OnCancel (Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt; interruption);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class System.IDisposable&gt; OnCancel(class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class Microsoft.FSharp.Core.Unit&gt; interruption) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.OnCancel(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OnCancel (interruption As FSharpFunc(Of Unit, Unit)) As FSharpAsync(Of IDisposable)" />
      <MemberSignature Language="F#" Value="static member OnCancel : (unit -&gt; unit) -&gt; Async&lt;IDisposable&gt;" Usage="Microsoft.FSharp.Control.Async.OnCancel interruption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.IDisposable&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interruption" Type="Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit&gt;" />
      </Parameters>
      <Docs>
        <param name="interruption">The function that is executed on the thread performing the
 cancellation.</param>
        <summary>Generates a scoped, cooperative cancellation handler for use within an asynchronous workflow.</summary>
        <returns>An asynchronous computation that triggers the interruption if it is cancelled
 before being disposed.</returns>
        <remarks>For example,
     <c>async { use! holder = Async.OnCancel interruption ... }</c> 
 generates an asynchronous computation where, if a cancellation happens any time during 
 the execution of the asynchronous computation in the scope of <c>holder</c>, then action 
 <c>interruption</c> is executed on the thread that is performing the cancellation. This can 
 be used to arrange for a computation to be asynchronously notified that a cancellation 
 has occurred, e.g. by setting a flag, or deregistering a pending I/O action.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parallel&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T[]&gt; Parallel&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt; computations);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T[]&gt; Parallel&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt;&gt; computations) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parallel(Of T) (computations As IEnumerable(Of FSharpAsync(Of T))) As FSharpAsync(Of T())" />
      <MemberSignature Language="F#" Value="static member Parallel : seq&lt;Async&lt;'T&gt;&gt; -&gt; Async&lt;'T[]&gt;" Usage="Microsoft.FSharp.Control.Async.Parallel computations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computations" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computations">A sequence of distinct computations to be parallelized.</param>
        <summary>Creates an asynchronous computation that executes all the given asynchronous computations, 
 initially queueing each as work items and using a fork/join pattern.</summary>
        <returns>A computation that returns an array of values from the sequence of input computations.</returns>
        <remarks>If all child computations succeed, an array of results is passed to the success continuation.
 
 If any child computation raises an exception, then the overall computation will trigger an 
 exception, and cancel the others. 

 The overall computation will respond to cancellation while executing the child computations.
 If cancelled, the computation will cancel any remaining child computations but will still wait
 for the other child computations to complete.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T RunSynchronously&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;int&gt; timeout, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T RunSynchronously&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; timeout, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.RunSynchronously``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RunSynchronously(Of T) (computation As FSharpAsync(Of T), timeout As FSharpOption(Of Integer), cancellationToken As FSharpOption(Of CancellationToken)) As T" />
      <MemberSignature Language="F#" Value="static member RunSynchronously : Async&lt;'T&gt; * option&lt;int&gt; * option&lt;System.Threading.CancellationToken&gt; -&gt; 'T" Usage="Microsoft.FSharp.Control.Async.RunSynchronously (computation, timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="timeout" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The computation to run.</param>
        <param name="timeout">The amount of time in milliseconds to wait for the result of the
 computation before raising a <c>System.TimeoutException</c>.  If no value is provided
 for timeout then a default of -1 is used to correspond to System.Threading.Timeout.Infinite.
 If a cancellable cancellationToken is provided, timeout parameter will be ignored</param>
        <param name="cancellationToken">The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</param>
        <summary>Runs the asynchronous computation and await its result.</summary>
        <returns>The result of the computation.</returns>
        <remarks>If an exception occurs in the asynchronous computation then an exception is re-raised by this
 function.
        
 If no cancellation token is provided then the default cancellation token is used.

 The timeout parameter is given in milliseconds.  A value of -1 is equivalent to
 System.Threading.Timeout.Infinite.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; Sleep (int millisecondsDueTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; Sleep(int32 millisecondsDueTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sleep (millisecondsDueTime As Integer) As FSharpAsync(Of Unit)" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; Async&lt;unit&gt;" Usage="Microsoft.FSharp.Control.Async.Sleep millisecondsDueTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDueTime" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDueTime">The number of milliseconds to sleep.</param>
        <summary>Creates an asynchronous computation that will sleep for the given time. This is scheduled
 using a System.Threading.Timer object. The operation will not block operating system threads
 for the duration of the wait.</summary>
        <returns>An asynchronous computation that will sleep for the given time.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentOutOfRangeException">Thrown when the due time is negative
 and not infinite.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static void Start (Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Start(class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.Start(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Start (computation As FSharpAsync(Of Unit), cancellationToken As FSharpOption(Of CancellationToken))" />
      <MemberSignature Language="F#" Value="static member Start : Async&lt;unit&gt; * option&lt;System.Threading.CancellationToken&gt; -&gt; unit" Usage="Microsoft.FSharp.Control.Async.Start (computation, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="computation">The computation to run asynchronously.</param>
        <param name="cancellationToken">The cancellation token to be associated with the computation.
 If one is not supplied, the default cancellation token is used.</param>
        <summary>Starts the asynchronous computation in the thread pool. Do not await its result.</summary>
        <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartAsTask&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;T&gt; StartAsTask&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.Tasks.TaskCreationOptions&gt; taskCreationOptions, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Threading.Tasks.Task`1&lt;!!T&gt; StartAsTask&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.Tasks.TaskCreationOptions&gt; taskCreationOptions, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartAsTask(Of T) (computation As FSharpAsync(Of T), taskCreationOptions As FSharpOption(Of TaskCreationOptions), cancellationToken As FSharpOption(Of CancellationToken)) As Task(Of T)" />
      <MemberSignature Language="F#" Value="static member StartAsTask : Async&lt;'T&gt; * option&lt;System.Threading.Tasks.TaskCreationOptions&gt; * option&lt;System.Threading.CancellationToken&gt; -&gt; System.Threading.Tasks.Task&lt;'T&gt;" Usage="Microsoft.FSharp.Control.Async.StartAsTask (computation, taskCreationOptions, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="taskCreationOptions" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.Tasks.TaskCreationOptions&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">To be added.</param>
        <param name="taskCreationOptions">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>Executes a computation in the thread pool.</summary>
        <returns>A <c>System.Threading.Tasks.Task</c> that will be completed
 in the corresponding state once the computation terminates (produces the result, throws exception or gets canceled)</returns>
        <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartChild&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt; StartChild&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;int&gt; millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt;&gt; StartChild&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartChild``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartChild(Of T) (computation As FSharpAsync(Of T), millisecondsTimeout As FSharpOption(Of Integer)) As FSharpAsync(Of FSharpAsync(Of T))" />
      <MemberSignature Language="F#" Value="static member StartChild : Async&lt;'T&gt; * option&lt;int&gt; -&gt; Async&lt;Async&lt;'T&gt;&gt;" Usage="Microsoft.FSharp.Control.Async.StartChild (computation, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="millisecondsTimeout" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The child computation.</param>
        <param name="millisecondsTimeout">The timeout value in milliseconds.  If one is not provided
 then the default value of -1 corresponding to <c>System.Threading.Timeout.Infinite</c>.</param>
        <summary>Starts a child computation within an asynchronous workflow. 
 This allows multiple asynchronous computations to be executed simultaneously.</summary>
        <returns>A new computation that waits for the input computation to finish.</returns>
        <remarks>This method should normally be used as the immediate 
 right-hand-side of a <c>let!</c> binding in an F# asynchronous workflow, that is,
 
        async { ...
                let! completor1 = childComputation1 |&gt; Async.StartChild  
                let! completor2 = childComputation2 |&gt; Async.StartChild  
                ... 
                let! result1 = completor1 
                let! result2 = completor2 
                ... }
 
 When used in this way, each use of <c>StartChild</c> starts an instance of <c>childComputation</c> 
 and returns a completor object representing a computation to wait for the completion of the operation.
 When executed, the completor awaits the completion of <c>childComputation</c>.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartChildAsTask&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;System.Threading.Tasks.Task&lt;T&gt;&gt; StartChildAsTask&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.Tasks.TaskCreationOptions&gt; taskCreationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class System.Threading.Tasks.Task`1&lt;!!T&gt;&gt; StartChildAsTask&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.Tasks.TaskCreationOptions&gt; taskCreationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartChildAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartChildAsTask(Of T) (computation As FSharpAsync(Of T), taskCreationOptions As FSharpOption(Of TaskCreationOptions)) As FSharpAsync(Of Task(Of T))" />
      <MemberSignature Language="F#" Value="static member StartChildAsTask : Async&lt;'T&gt; * option&lt;System.Threading.Tasks.TaskCreationOptions&gt; -&gt; Async&lt;System.Threading.Tasks.Task&lt;'T&gt;&gt;" Usage="Microsoft.FSharp.Control.Async.StartChildAsTask (computation, taskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;System.Threading.Tasks.Task&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="taskCreationOptions" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.Tasks.TaskCreationOptions&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">To be added.</param>
        <param name="taskCreationOptions">To be added.</param>
        <summary>Creates an asynchronous computation which starts the given computation as a <c>System.Threading.Tasks.Task</c></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartImmediate">
      <MemberSignature Language="C#" Value="public static void StartImmediate (Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static void StartImmediate(class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartImmediate(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StartImmediate (computation As FSharpAsync(Of Unit), cancellationToken As FSharpOption(Of CancellationToken))" />
      <MemberSignature Language="F#" Value="static member StartImmediate : Async&lt;unit&gt; * option&lt;System.Threading.CancellationToken&gt; -&gt; unit" Usage="Microsoft.FSharp.Control.Async.StartImmediate (computation, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="computation">The asynchronous computation to execute.</param>
        <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>
        <summary>Runs an asynchronous computation, starting immediately on the current operating system
 thread.</summary>
        <remarks>If no cancellation token is provided then the default cancellation token is used.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartImmediateAsTask&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;T&gt; StartImmediateAsTask&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Threading.Tasks.Task`1&lt;!!T&gt; StartImmediateAsTask&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartImmediateAsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StartImmediateAsTask(Of T) (computation As FSharpAsync(Of T), cancellationToken As FSharpOption(Of CancellationToken)) As Task(Of T)" />
      <MemberSignature Language="F#" Value="static member StartImmediateAsTask : Async&lt;'T&gt; * option&lt;System.Threading.CancellationToken&gt; -&gt; System.Threading.Tasks.Task&lt;'T&gt;" Usage="Microsoft.FSharp.Control.Async.StartImmediateAsTask (computation, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The asynchronous computation to execute.</param>
        <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>
        <summary>Runs an asynchronous computation, starting immediately on the current operating system, 
 but also returns the execution as <c>System.Threading.Tasks.Task</c></summary>
        <returns>A <c>System.Threading.Tasks.Task</c> that will be completed
 in the corresponding state once the computation terminates (produces the result, throws exception or gets canceled)</returns>
        <remarks>If no cancellation token is provided then the default cancellation token is used.
 You may prefer using this method if you want to achive a similar behviour to async await in C# as 
 async computation starts on the current thread with an ability to return a result.
 </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartWithContinuations&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StartWithContinuations&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt; continuation, Microsoft.FSharp.Core.FSharpFunc&lt;Exception,Microsoft.FSharp.Core.Unit&gt; exceptionContinuation, Microsoft.FSharp.Core.FSharpFunc&lt;OperationCanceledException,Microsoft.FSharp.Core.Unit&gt; cancellationContinuation, Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt; cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static void StartWithContinuations&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt; continuation, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.Exception, class Microsoft.FSharp.Core.Unit&gt; exceptionContinuation, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.OperationCanceledException, class Microsoft.FSharp.Core.Unit&gt; cancellationContinuation, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Threading.CancellationToken&gt; cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.StartWithContinuations``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub StartWithContinuations(Of T) (computation As FSharpAsync(Of T), continuation As FSharpFunc(Of T, Unit), exceptionContinuation As FSharpFunc(Of Exception, Unit), cancellationContinuation As FSharpFunc(Of OperationCanceledException, Unit), cancellationToken As FSharpOption(Of CancellationToken))" />
      <MemberSignature Language="F#" Value="static member StartWithContinuations : Async&lt;'T&gt; * ('T -&gt; unit) * (Exception -&gt; unit) * (OperationCanceledException -&gt; unit) * option&lt;System.Threading.CancellationToken&gt; -&gt; unit" Usage="Microsoft.FSharp.Control.Async.StartWithContinuations (computation, continuation, exceptionContinuation, cancellationContinuation, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="continuation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="exceptionContinuation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Exception,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="cancellationContinuation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.OperationCanceledException,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="cancellationToken" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Threading.CancellationToken&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The asynchronous computation to execute.</param>
        <param name="continuation">The function called on success.</param>
        <param name="exceptionContinuation">The function called on exception.</param>
        <param name="cancellationContinuation">The function called on cancellation.</param>
        <param name="cancellationToken">The <c>CancellationToken</c> to associate with the computation.
 The default is used if this parameter is not provided.</param>
        <summary>Runs an asynchronous computation, starting immediately on the current operating system
 thread. Call one of the three continuations when the operation completes.</summary>
        <remarks>If no cancellation token is provided then the default cancellation token
 is used.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchToContext">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; SwitchToContext (System.Threading.SynchronizationContext syncContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; SwitchToContext(class System.Threading.SynchronizationContext syncContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToContext(System.Threading.SynchronizationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchToContext (syncContext As SynchronizationContext) As FSharpAsync(Of Unit)" />
      <MemberSignature Language="F#" Value="static member SwitchToContext : System.Threading.SynchronizationContext -&gt; Async&lt;unit&gt;" Usage="Microsoft.FSharp.Control.Async.SwitchToContext syncContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="syncContext" Type="System.Threading.SynchronizationContext" />
      </Parameters>
      <Docs>
        <param name="syncContext">The synchronization context to accept the posted computation.</param>
        <summary>Creates an asynchronous computation that runs
 its continuation using syncContext.Post. If syncContext is null 
 then the asynchronous computation is equivalent to SwitchToThreadPool().</summary>
        <returns>An asynchronous computation that uses the syncContext context to execute.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchToNewThread">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; SwitchToNewThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; SwitchToNewThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToNewThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchToNewThread () As FSharpAsync(Of Unit)" />
      <MemberSignature Language="F#" Value="static member SwitchToNewThread : unit -&gt; Async&lt;unit&gt;" Usage="Microsoft.FSharp.Control.Async.SwitchToNewThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an asynchronous computation that creates a new thread and runs
 its continuation in that thread.</summary>
        <returns>A computation that will execute on a new thread.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SwitchToThreadPool">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt; SwitchToThreadPool ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;class Microsoft.FSharp.Core.Unit&gt; SwitchToThreadPool() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.SwitchToThreadPool" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SwitchToThreadPool () As FSharpAsync(Of Unit)" />
      <MemberSignature Language="F#" Value="static member SwitchToThreadPool : unit -&gt; Async&lt;unit&gt;" Usage="Microsoft.FSharp.Control.Async.SwitchToThreadPool " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;Microsoft.FSharp.Core.Unit&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an asynchronous computation that queues a work item that runs
 its continuation.</summary>
        <returns>A computation that generates a new work item in the thread pool.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCancelled&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; TryCancelled&lt;T&gt; (Microsoft.FSharp.Control.FSharpAsync&lt;T&gt; computation, Microsoft.FSharp.Core.FSharpFunc&lt;OperationCanceledException,Microsoft.FSharp.Core.Unit&gt; compensation);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; TryCancelled&lt;T&gt;(class Microsoft.FSharp.Control.FSharpAsync`1&lt;!!T&gt; computation, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class System.OperationCanceledException, class Microsoft.FSharp.Core.Unit&gt; compensation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.FSharpAsync.TryCancelled``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{System.OperationCanceledException,Microsoft.FSharp.Core.Unit})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCancelled(Of T) (computation As FSharpAsync(Of T), compensation As FSharpFunc(Of OperationCanceledException, Unit)) As FSharpAsync(Of T)" />
      <MemberSignature Language="F#" Value="static member TryCancelled : Async&lt;'T&gt; * (OperationCanceledException -&gt; unit) -&gt; Async&lt;'T&gt;" Usage="Microsoft.FSharp.Control.Async.TryCancelled (computation, compensation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="computation" Type="Microsoft.FSharp.Control.FSharpAsync&lt;T&gt;" />
        <Parameter Name="compensation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.OperationCanceledException,Microsoft.FSharp.Core.Unit&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="computation">The input asynchronous computation.</param>
        <param name="compensation">The function to be run if the computation is cancelled.</param>
        <summary>Creates an asynchronous computation that executes <c>computation</c>.
 If this computation is cancelled before it completes then the computation generated by 
 running <c>compensation</c> is executed.</summary>
        <returns>An asynchronous computation that runs the compensation if the input computation
 is cancelled.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>