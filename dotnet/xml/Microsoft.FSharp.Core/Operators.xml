<Type Name="Operators" FullName="Microsoft.FSharp.Core.Operators">
  <TypeSignature Language="C#" Value="public static class Operators" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Operators extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Core.Operators" />
  <TypeSignature Language="VB.NET" Value="Public Class Operators" />
  <TypeSignature Language="F#" Value="module Operators" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.4.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.AutoOpen</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.Module)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Basic F# Operators. This module is automatically opened in all F# code.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Abs&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Abs&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Abs``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.abs : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("abs")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Absolute value of the given number.</summary>
        <returns>The absolute value of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Acos&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Acos&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Acos``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.acos : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("acos")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Inverse cosine of the given number</summary>
        <returns>The inverse cosine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Asin&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Asin&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Asin``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.asin : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("asin")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Inverse sine of the given number</summary>
        <returns>The inverse sine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Atan&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Atan&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Atan``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.atan : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("atan")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Inverse tangent of the given number</summary>
        <returns>The inverse tangent of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static T2 Atan2&lt;T1,T2&gt; (T1 y, T1 x);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T2 Atan2&lt;T1, T2&gt;(!!T1 y, !!T1 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Atan2``2(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2(Of T1, T2) (y As T1, x As T1) As T2" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.atan2 : 'T1 -&gt; 'T1 -&gt; 'T2" Usage="Microsoft.FSharp.Core.Operators.Atan2 y x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("atan2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="T1" />
        <Parameter Name="x" Type="T1" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="y">The y input value.</param>
        <param name="x">The x input value.</param>
        <summary>Inverse tangent of <c>x/y</c> where <c>x</c> and <c>y</c> are specified separately</summary>
        <returns>The inverse tangent of the input ratio.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Box&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static object Box&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Box&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Box``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Box(Of T) (value As T) As Object" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.box : 'T -&gt; obj" Usage="Microsoft.FSharp.Core.Operators.Box value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("box")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to box.</param>
        <summary>Boxes a strongly typed value.</summary>
        <returns>The boxed object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Ceiling&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Ceiling&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Ceiling``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.ceil : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Ceiling value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ceil")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Ceiling of the given number</summary>
        <returns>The ceiling of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Compare&lt;T&gt; (T e1, T e2);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Compare&lt;T&gt;(!!T e1, !!T e2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Compare``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare(Of T) (e1 As T, e2 As T) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.compare : 'T -&gt; 'T -&gt; int" Usage="Microsoft.FSharp.Core.Operators.Compare e1 e2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("compare")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="e1" Type="T" />
        <Parameter Name="e2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="e1">The first value.</param>
        <param name="e2">The second value.</param>
        <summary>Generic comparison.</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConsoleError&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter ConsoleError&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.TextWriter ConsoleError&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ConsoleError``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConsoleError(Of T) () As TextWriter" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.stderr : unit -&gt; System.IO.TextWriter" Usage="Microsoft.FSharp.Core.Operators.ConsoleError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("stderr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Reads the value of the property <c>System.Console.Error</c>. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConsoleIn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader ConsoleIn&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.TextReader ConsoleIn&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ConsoleIn``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConsoleIn(Of T) () As TextReader" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.stdin : unit -&gt; System.IO.TextReader" Usage="Microsoft.FSharp.Core.Operators.ConsoleIn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("stdin")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Reads the value of the property <c>System.Console.In</c>. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConsoleOut&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter ConsoleOut&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.TextWriter ConsoleOut&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ConsoleOut``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConsoleOut(Of T) () As TextWriter" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.stdout : unit -&gt; System.IO.TextWriter" Usage="Microsoft.FSharp.Core.Operators.ConsoleOut " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("stdout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Reads the value of the property <c>System.Console.Out</c>.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Cos&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Cos&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Cos``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.cos : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("cos")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Cosine of the given number</summary>
        <returns>The cosine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Cosh&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Cosh&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Cosh``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.cosh : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("cosh")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Hyperbolic cosine  of the given number</summary>
        <returns>The hyperbolic cosine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSequence&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; CreateSequence&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; sequence);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; CreateSequence&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; sequence) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.CreateSequence``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSequence(Of T) (sequence As IEnumerable(Of T)) As IEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.seq : seq&lt;'T&gt; -&gt; seq&lt;'T&gt;" Usage="Microsoft.FSharp.Core.Operators.CreateSequence sequence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("seq")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="sequence">The input sequence.</param>
        <summary>Builds a sequence using sequence expression syntax</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static void Decrement (Microsoft.FSharp.Core.FSharpRef&lt;int&gt; cell);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Decrement(class Microsoft.FSharp.Core.FSharpRef`1&lt;int32&gt; cell) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Decrement(Microsoft.FSharp.Core.FSharpRef{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrement (cell As FSharpRef(Of Integer))" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.decr : ref&lt;int&gt; -&gt; unit" Usage="Microsoft.FSharp.Core.Operators.Decrement cell" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("decr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cell" Type="Microsoft.FSharp.Core.FSharpRef&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="cell">The reference cell.</param>
        <summary>Decrement a mutable reference cell containing an integer</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultArg&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T DefaultArg&lt;T&gt; (Microsoft.FSharp.Core.FSharpOption&lt;T&gt; arg, T defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T DefaultArg&lt;T&gt;(class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; arg, !!T defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.DefaultArg``1(Microsoft.FSharp.Core.FSharpOption{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DefaultArg(Of T) (arg As FSharpOption(Of T), defaultValue As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.defaultArg : option&lt;'T&gt; -&gt; 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.DefaultArg arg defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("defaultArg")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg" Type="Microsoft.FSharp.Core.FSharpOption&lt;T&gt;" />
        <Parameter Name="defaultValue" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="arg">An option representing the argument.</param>
        <param name="defaultValue">The default value of the argument.</param>
        <summary>Used to specify a default value for an optional argument in the implementation of a function</summary>
        <returns>The argument value. If it is None, the defaultValue is returned.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exit&lt;T&gt; (int exitcode);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Exit&lt;T&gt;(int32 exitcode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Exit``1(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exit(Of T) (exitcode As Integer) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.exit : int -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Exit exitcode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exitcode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="exitcode">The exit code to use.</param>
        <summary>Exit the current hardware isolated process, if security settings permit,
 otherwise raise an exception. Calls <c>System.Environment.Exit</c>.</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exp&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Exp&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Exp``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.exp : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Exponential of the given number</summary>
        <returns>The exponential of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Failure">
      <MemberSignature Language="C#" Value="public static Exception Failure (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Exception Failure(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Failure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Failure (message As String) As Exception" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.Failure : string -&gt; Exception" Usage="Microsoft.FSharp.Core.Operators.Failure message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">The message for the Exception.</param>
        <summary>Builds a <c>System.Exception</c> object.</summary>
        <returns>A System.Exception.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FailurePattern">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;string&gt; FailurePattern (Exception error);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;string&gt; FailurePattern(class System.Exception error) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.FailurePattern(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FailurePattern (error As Exception) As FSharpOption(Of String)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.|Failure|_| : Exception -&gt; option&lt;string&gt;" Usage="Microsoft.FSharp.Core.Operators.FailurePattern error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("|Failure|_|")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="error">The input exception.</param>
        <summary>Matches <c>System.Exception</c> objects whose runtime type is precisely <c>System.Exception</c></summary>
        <returns>A string option.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FailWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FailWith&lt;T&gt; (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T FailWith&lt;T&gt;(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.FailWith``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FailWith(Of T) (message As String) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.failwith : string -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.FailWith message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("failwith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="message">The exception message.</param>
        <summary>Throw a <c>System.Exception</c> exception.</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Floor&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Floor&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Floor``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.floor : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Floor value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("floor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Floor of the given number</summary>
        <returns>The floor of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fst&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static T1 Fst&lt;T1,T2&gt; (Tuple&lt;T1,T2&gt; tuple);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T1 Fst&lt;T1, T2&gt;(class System.Tuple`2&lt;!!T1, !!T2&gt; tuple) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Fst``2(System.Tuple{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Fst(Of T1, T2) (tuple As Tuple(Of T1, T2)) As T1" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.fst : ('T1 * 'T2) -&gt; 'T1" Usage="Microsoft.FSharp.Core.Operators.Fst tuple" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fst")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T1</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tuple" Type="System.Tuple&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="tuple">The input tuple.</param>
        <summary>Return the first element of a tuple, <c>fst (a,b) = a</c>.</summary>
        <returns>The first value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hash&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Hash&lt;T&gt; (T obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Hash&lt;T&gt;(!!T obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Hash``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Hash(Of T) (obj As T) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.hash : 'T -&gt; int" Usage="Microsoft.FSharp.Core.Operators.Hash obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("hash")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="obj">The input object.</param>
        <summary>A generic hash function, designed to return equal hash values for items that are 
 equal according to the "=" operator. By default it will use structural hashing
 for F# union, record and tuple types, hashing the complete contents of the 
 type. The exact behaviour of the function can be adjusted on a 
 type-by-type basis by implementing GetHashCode for each type.</summary>
        <returns>The computed hash.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Identity&lt;T&gt; (T x);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Identity&lt;T&gt;(!!T x) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Identity``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Identity(Of T) (x As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.id : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Identity x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("id")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input value.</param>
        <summary>The identity function</summary>
        <returns>The same value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ignore&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Ignore&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Ignore``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ignore(Of T) (value As T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.ignore : 'T -&gt; unit" Usage="Microsoft.FSharp.Core.Operators.Ignore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ignore")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to ignore.</param>
        <summary>Ignore the passed value. This is often used to throw away results of a computation.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static void Increment (Microsoft.FSharp.Core.FSharpRef&lt;int&gt; cell);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Increment(class Microsoft.FSharp.Core.FSharpRef`1&lt;int32&gt; cell) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Increment(Microsoft.FSharp.Core.FSharpRef{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Increment (cell As FSharpRef(Of Integer))" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.incr : ref&lt;int&gt; -&gt; unit" Usage="Microsoft.FSharp.Core.Operators.Increment cell" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("incr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cell" Type="Microsoft.FSharp.Core.FSharpRef&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="cell">The reference cell.</param>
        <summary>Increment a mutable reference cell containing an integer</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Infinity">
      <MemberSignature Language="C#" Value="public static double Infinity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 Infinity" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Core.Operators.Infinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Infinity As Double" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.Infinity : double" Usage="Microsoft.FSharp.Core.Operators.Infinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompiledName("Infinity")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Equivalent to <c>System.Double.PositiveInfinity</c></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InfinitySingle">
      <MemberSignature Language="C#" Value="public static float InfinitySingle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float32 InfinitySingle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Core.Operators.InfinitySingle" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InfinitySingle As Single" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.InfinitySingle : single" Usage="Microsoft.FSharp.Core.Operators.InfinitySingle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompiledName("InfinitySingle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Equivalent to <c>System.Single.PositiveInfinity</c></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidArg&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T InvalidArg&lt;T&gt; (string argumentName, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T InvalidArg&lt;T&gt;(string argumentName, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.InvalidArg``1(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InvalidArg(Of T) (argumentName As String, message As String) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.invalidArg : string -&gt; string -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.InvalidArg argumentName message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("invalidArg")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="argumentName" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="argumentName">The argument name.</param>
        <param name="message">The exception message.</param>
        <summary>Throw a <c>System.ArgumentException</c> exception with
 the given argument name and message.</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidOp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T InvalidOp&lt;T&gt; (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T InvalidOp&lt;T&gt;(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.InvalidOp``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function InvalidOp(Of T) (message As String) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.invalidOp : string -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.InvalidOp message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("invalidOp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="message">The exception message.</param>
        <summary>Throw a <c>System.InvalidOperationException</c> exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNull&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNull&lt;T&gt; (T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static bool IsNull&lt;class T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.IsNull``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNull(Of T As Class) (value As T) As Boolean" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.isNull : 'T -&gt; bool (requires 'T : null)" Usage="Microsoft.FSharp.Core.Operators.IsNull value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("isNull")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to check.</param>
        <summary>Determines whether the given value is null.</summary>
        <returns>True when value is null, false otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyValuePattern&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TKey,TValue&gt; KeyValuePattern&lt;TKey,TValue&gt; (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TKey, !!TValue&gt; KeyValuePattern&lt;TKey, TValue&gt;(valuetype System.Collections.Generic.KeyValuePair`2&lt;!!TKey, !!TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.KeyValuePattern``2(System.Collections.Generic.KeyValuePair{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function KeyValuePattern(Of TKey, TValue) (keyValuePair As KeyValuePair(Of TKey, TValue)) As Tuple(Of TKey, TValue)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.|KeyValue| : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt; -&gt; 'Key * 'Value" Usage="Microsoft.FSharp.Core.Operators.KeyValuePattern keyValuePair" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("|KeyValue|")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keyValuePair">The input key/value pair.</param>
        <summary>An active pattern to match values of type <c>System.Collections.Generic.KeyValuePair</c></summary>
        <returns>A tuple containing the key and value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="limitedHash&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int limitedHash&lt;T&gt; (int limit, T obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 limitedHash&lt;T&gt;(int32 limit, !!T obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.limitedHash``1(System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function limitedHash(Of T) (limit As Integer, obj As T) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.limitedHash : int -&gt; 'T -&gt; int" Usage="Microsoft.FSharp.Core.Operators.limitedHash limit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="limit" Type="System.Int32" />
        <Parameter Name="obj" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="limit">The limit of nodes.</param>
        <param name="obj">The input object.</param>
        <summary>A generic hash function. This function has the same behaviour as 'hash', 
 however the default structural hashing for F# union, record and tuple 
 types stops when the given limit of nodes is reached. The exact behaviour of 
 the function can be adjusted on a type-by-type basis by implementing 
 GetHashCode for each type.</summary>
        <returns>The computed hash.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock&lt;TLock,T&gt;">
      <MemberSignature Language="C#" Value="public static T Lock&lt;TLock,T&gt; (TLock lockObject, Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,T&gt; action) where TLock : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Lock&lt;class TLock, T&gt;(!!TLock lockObject, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, !!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Lock``2(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lock(Of TLock As Class, T As Class) (lockObject As TLock, action As FSharpFunc(Of Unit, T)) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.lock : 'Lock -&gt; (unit -&gt; 'T) -&gt; 'T (requires 'Lock : null)" Usage="Microsoft.FSharp.Core.Operators.Lock lockObject action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("lock")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLock">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="lockObject" Type="TLock" />
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLock">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="lockObject">The object to be locked.</param>
        <param name="action">The action to perform during the lock.</param>
        <summary>Execute the function as a mutual-exclusion region using the input value as a lock. </summary>
        <returns>The resulting value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Log&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Log&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Log``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.log : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("log")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Natural logarithm of the given number</summary>
        <returns>The natural logarithm of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Log10&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Log10&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Log10``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.log10 : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("log10")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Logarithm to base 10 of the given number</summary>
        <returns>The logarithm to base 10 of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (T e1, T e2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Max&lt;T&gt;(!!T e1, !!T e2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Max``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max(Of T) (e1 As T, e2 As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.max : 'T -&gt; 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Max e1 e2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("max")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="e1" Type="T" />
        <Parameter Name="e2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="e1">The first value.</param>
        <param name="e2">The second value.</param>
        <summary>Maximum based on generic comparison</summary>
        <returns>The maximum value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (T e1, T e2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Min&lt;T&gt;(!!T e1, !!T e2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Min``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min(Of T) (e1 As T, e2 As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.min : 'T -&gt; 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Min e1 e2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("min")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="e1" Type="T" />
        <Parameter Name="e2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="e1">The first value.</param>
        <param name="e2">The second value.</param>
        <summary>Minimum based on generic comparison</summary>
        <returns>The minimum value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public static double NaN { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 NaN" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Core.Operators.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NaN As Double" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.NaN : double" Usage="Microsoft.FSharp.Core.Operators.NaN" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompiledName("NaN")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Equivalent to <c>System.Double.NaN</c></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NaNSingle">
      <MemberSignature Language="C#" Value="public static float NaNSingle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float32 NaNSingle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Core.Operators.NaNSingle" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NaNSingle As Single" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.NaNSingle : single" Usage="Microsoft.FSharp.Core.Operators.NaNSingle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompiledName("NaNSingle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Equivalent to <c>System.Single.NaN</c></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static bool Not (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Not(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Not(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Not (value As Boolean) As Boolean" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.not : bool -&gt; bool" Usage="Microsoft.FSharp.Core.Operators.Not value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("not")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">The value to negate.</param>
        <summary>Negate a logical value. Not True equals False and not False equals True</summary>
        <returns>The result of the negation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NullArg&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T NullArg&lt;T&gt; (string argumentName);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T NullArg&lt;T&gt;(string argumentName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.NullArg``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NullArg(Of T) (argumentName As String) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.nullArg : string -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.NullArg argumentName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("nullArg")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="argumentName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="argumentName">The argument name.</param>
        <summary>Throw a <c>System.ArgumentNullException</c> exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 operator +&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Addition&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Addition``3(``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator +(Of T1, T2, T3) (x As T1, y As T2) As T3" />
      <MemberSignature Language="F#" Value="( + ) : 'T1 -&gt; 'T2 -&gt; 'T3" Usage="x + y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded addition operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Append&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; op_Append&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; op_Append&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Append(Of T) (list1 As FSharpList(Of T), list2 As FSharpList(Of T)) As FSharpList(Of T)" />
      <MemberSignature Language="F#" Value="( @ ) : List&lt;'T&gt; -&gt; List&lt;'T&gt; -&gt; List&lt;'T&gt;" Usage="list1 @ list2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list1">The first list.</param>
        <param name="list2">The second list.</param>
        <summary>Concatenate two lists.</summary>
        <returns>The concatenation of the lists.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T operator &amp;&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_BitwiseAnd&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_BitwiseAnd``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And(Of T) (x As T, y As T) As T" />
      <MemberSignature Language="F#" Value="( &amp;&amp;&amp; ) : 'T -&gt; 'T -&gt; 'T" Usage="x &amp;&amp;&amp; y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded bitwise-AND operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T operator |&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_BitwiseOr&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_BitwiseOr``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or(Of T) (x As T, y As T) As T" />
      <MemberSignature Language="F#" Value="( ||| ) : 'T -&gt; 'T -&gt; 'T" Usage="x ||| y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded bitwise-OR operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ColonEquals&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void op_ColonEquals&lt;T&gt; (Microsoft.FSharp.Core.FSharpRef&lt;T&gt; cell, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname void op_ColonEquals&lt;T&gt;(class Microsoft.FSharp.Core.FSharpRef`1&lt;!!T&gt; cell, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_ColonEquals``1(Microsoft.FSharp.Core.FSharpRef{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_ColonEquals(Of T) (cell As FSharpRef(Of T), value As T)" />
      <MemberSignature Language="F#" Value="( := ) : ref&lt;'T&gt; -&gt; 'T -&gt; unit" Usage="cell := value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cell" Type="Microsoft.FSharp.Core.FSharpRef&lt;T&gt;" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="cell">The cell to mutate.</param>
        <param name="value">The value to set inside the cell.</param>
        <summary>Assign to a mutable reference cell</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ComposeLeft&lt;T2,T3,T1&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;T1,T3&gt; op_ComposeLeft&lt;T2,T3,T1&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T2,T3&gt; func2, Microsoft.FSharp.Core.FSharpFunc&lt;T1,T2&gt; func1);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!T3&gt; op_ComposeLeft&lt;T2, T3, T1&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!T3&gt; func2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!T2&gt; func1) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_ComposeLeft``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_ComposeLeft(Of T2, T3, T1) (func2 As FSharpFunc(Of T2, T3), func1 As FSharpFunc(Of T1, T2)) As FSharpFunc(Of T1, T3)" />
      <MemberSignature Language="F#" Value="( &lt;&lt; ) : ('T2 -&gt; 'T3) -&gt; ('T1 -&gt; 'T2) -&gt; ('T1 -&gt; 'T3)" Usage="func2 &lt;&lt; func1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;T1,T3&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func2" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T2,T3&gt;" />
        <Parameter Name="func1" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="T1">To be added.</typeparam>
        <param name="func2">The second function to apply.</param>
        <param name="func1">The first function to apply.</param>
        <summary>Compose two functions, the function on the right being applied first</summary>
        <returns>The composition of the input functions.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ComposeRight&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;T1,T3&gt; op_ComposeRight&lt;T1,T2,T3&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,T2&gt; func1, Microsoft.FSharp.Core.FSharpFunc&lt;T2,T3&gt; func2);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!T3&gt; op_ComposeRight&lt;T1, T2, T3&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!T2&gt; func1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!T3&gt; func2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_ComposeRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_ComposeRight(Of T1, T2, T3) (func1 As FSharpFunc(Of T1, T2), func2 As FSharpFunc(Of T2, T3)) As FSharpFunc(Of T1, T3)" />
      <MemberSignature Language="F#" Value="( &gt;&gt; ) : ('T1 -&gt; 'T2) -&gt; ('T2 -&gt; 'T3) -&gt; ('T1 -&gt; 'T3)" Usage="func1 &gt;&gt; func2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;T1,T3&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func1" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,T2&gt;" />
        <Parameter Name="func2" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T2,T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="func1">The first function to apply.</param>
        <param name="func2">The second function to apply.</param>
        <summary>Compose two functions, the function on the left being applied first</summary>
        <returns>The composition of the input functions.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Concatenate">
      <MemberSignature Language="C#" Value="public static string op_Concatenate (string s1, string s2);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname string op_Concatenate(string s1, string s2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Concatenate(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Concatenate (s1 As String, s2 As String) As String" />
      <MemberSignature Language="F#" Value="( ^ ) : string -&gt; string -&gt; string" Usage="s1 ^ s2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilerMessage("This construct is for ML compatibility. Consider using the '+' operator instead. This may require a type annotation to indicate it acts on strings. This message can be disabled using '--nowarn:62' or '#nowarn "62"'.", 62, IsHidden=true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s1" Type="System.String" />
        <Parameter Name="s2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s1">To be added.</param>
        <param name="s2">To be added.</param>
        <summary>Concatenate two strings. The operator '+' may also be used.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Dereference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_Dereference&lt;T&gt; (Microsoft.FSharp.Core.FSharpRef&lt;T&gt; cell);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_Dereference&lt;T&gt;(class Microsoft.FSharp.Core.FSharpRef`1&lt;!!T&gt; cell) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Dereference``1(Microsoft.FSharp.Core.FSharpRef{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Dereference(Of T) (cell As FSharpRef(Of T)) As T" />
      <MemberSignature Language="F#" Value="( ! ) : ref&lt;'T&gt; -&gt; 'T" Usage="! cell" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cell" Type="Microsoft.FSharp.Core.FSharpRef&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="cell">The cell to dereference.</param>
        <summary>Dereference a mutable reference cell</summary>
        <returns>The value contained in the cell.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Division&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 operator /&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Division&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Division``3(``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator /(Of T1, T2, T3) (x As T1, y As T2) As T3" />
      <MemberSignature Language="F#" Value="( / ) : 'T1 -&gt; 'T2 -&gt; 'T3" Usage="x / y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded division operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool operator ==&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_Equality&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Equality``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator ==(Of T) (x As T, y As T) As Boolean" />
      <MemberSignature Language="F#" Value="( = ) : 'T -&gt; 'T -&gt; bool" Usage="x = y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural equality</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T operator ^&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_ExclusiveOr&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_ExclusiveOr``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor(Of T) (x As T, y As T) As T" />
      <MemberSignature Language="F#" Value="( ^^^ ) : 'T -&gt; 'T -&gt; 'T" Usage="x ^^^ y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded bitwise-XOR operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Exponentiation&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T op_Exponentiation&lt;T,TResult&gt; (T x, TResult y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_Exponentiation&lt;T, TResult&gt;(!!T x, !!TResult y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Exponentiation``2(``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Exponentiation(Of T, TResult) (x As T, y As TResult) As T" />
      <MemberSignature Language="F#" Value="op_Exponentiation : 'T -&gt; 'Result -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.op_Exponentiation x y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="x">The input base.</param>
        <param name="y">The input exponent.</param>
        <summary>Overloaded power operator.</summary>
        <returns>The base raised to the exponent.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool operator &gt;&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_GreaterThan&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_GreaterThan``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;(Of T) (x As T, y As T) As Boolean" />
      <MemberSignature Language="F#" Value="( &gt; ) : 'T -&gt; 'T -&gt; bool" Usage="x &gt; y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural greater-than</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool operator &gt;=&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_GreaterThanOrEqual&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_GreaterThanOrEqual``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;=(Of T) (x As T, y As T) As Boolean" />
      <MemberSignature Language="F#" Value="( &gt;= ) : 'T -&gt; 'T -&gt; bool" Usage="x &gt;= y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural greater-than-or-equal</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool operator !=&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_Inequality&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Inequality``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator !=(Of T) (x As T, y As T) As Boolean" />
      <MemberSignature Language="F#" Value="op_Inequality : 'T -&gt; 'T -&gt; bool" Usage="Microsoft.FSharp.Core.Operators.op_Inequality x y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural inequality</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T operator &lt;&lt;&lt;T&gt; (T value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_LeftShift&lt;T&gt;(!!T value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_LeftShift``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt;(Of T) (value As T, shift As Integer) As T" />
      <MemberSignature Language="F#" Value="( &lt;&lt;&lt; ) : 'T -&gt; int -&gt; 'T" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <param name="shift">The amount to shift.</param>
        <summary>Overloaded byte-shift left operator by a specified number of bits</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool operator &lt;&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_LessThan&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_LessThan``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;(Of T) (x As T, y As T) As Boolean" />
      <MemberSignature Language="F#" Value="( &lt; ) : 'T -&gt; 'T -&gt; bool" Usage="x &lt; y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural less-than comparison</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool operator &lt;=&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_LessThanOrEqual&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_LessThanOrEqual``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;=(Of T) (x As T, y As T) As Boolean" />
      <MemberSignature Language="F#" Value="( &lt;= ) : 'T -&gt; 'T -&gt; bool" Usage="x &lt;= y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural less-than-or-equal comparison</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LogicalNot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T operator !&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_LogicalNot&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_LogicalNot``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="( ~~~ ) : 'T -&gt; 'T" Usage="~~~ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Overloaded bitwise-NOT operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Modulus&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 operator %&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Modulus&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Modulus``3(``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod(Of T1, T2, T3) (x As T1, y As T2) As T3" />
      <MemberSignature Language="F#" Value="( % ) : 'T1 -&gt; 'T2 -&gt; 'T3" Usage="x % y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded modulo operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 operator *&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Multiply&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Multiply``3(``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator *(Of T1, T2, T3) (x As T1, y As T2) As T3" />
      <MemberSignature Language="F#" Value="( * ) : 'T1 -&gt; 'T2 -&gt; 'T3" Usage="x * y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded multiplication operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeLeft&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeLeft&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; func, T arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeLeft&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; func, !!T arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeLeft``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_PipeLeft(Of T, TResult) (func As FSharpFunc(Of T, TResult), arg1 As T) As TResult" />
      <MemberSignature Language="F#" Value="( &lt;| ) : ('T -&gt; 'Result) -&gt; 'T -&gt; 'Result" Usage="func &lt;| arg1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="arg1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="func">The function.</param>
        <param name="arg1">The argument.</param>
        <summary>Apply a function to a value, the value being on the right, the function on the left</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeLeft2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeLeft2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt; func, T1 arg1, T2 arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeLeft2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt; func, !!T1 arg1, !!T2 arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeLeft2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_PipeLeft2(Of T1, T2, TResult) (func As FSharpFunc(Of T1, FSharpFunc(Of T2, TResult)), arg1 As T1, arg2 As T2) As TResult" />
      <MemberSignature Language="F#" Value="( &lt;|| ) : ('T1 -&gt; 'T2 -&gt; 'Result) -&gt; 'T1 * 'T2 -&gt; 'Result" Usage="func &lt;|| (arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;" />
        <Parameter Name="arg1" Type="T1" />
        <Parameter Name="arg2" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="func">The function.</param>
        <param name="arg1">The first argument.</param>
        <param name="arg2">The second argument.</param>
        <summary>Apply a function to two values, the values being a pair on the right, the function on the left</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeLeft3&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeLeft3&lt;T1,T2,T3,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt; func, T1 arg1, T2 arg2, T3 arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeLeft3&lt;T1, T2, T3, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T3, !!TResult&gt;&gt;&gt; func, !!T1 arg1, !!T2 arg2, !!T3 arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeLeft3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0,``1,``2)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_PipeLeft3(Of T1, T2, T3, TResult) (func As FSharpFunc(Of T1, FSharpFunc(Of T2, FSharpFunc(Of T3, TResult))), arg1 As T1, arg2 As T2, arg3 As T3) As TResult" />
      <MemberSignature Language="F#" Value="( &lt;||| ) : ('T1 -&gt; 'T2 -&gt; 'T3 -&gt; 'Result) -&gt; 'T1 * 'T2 * 'T3 -&gt; 'Result" Usage="func &lt;||| (arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt;" />
        <Parameter Name="arg1" Type="T1" />
        <Parameter Name="arg2" Type="T2" />
        <Parameter Name="arg3" Type="T3" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="func">The function.</param>
        <param name="arg1">The first argument.</param>
        <param name="arg2">The second argument.</param>
        <param name="arg3">The third argument.</param>
        <summary>Apply a function to three values, the values being a triple on the right, the function on the left</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeRight&lt;T1,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeRight&lt;T1,TResult&gt; (T1 arg, Microsoft.FSharp.Core.FSharpFunc&lt;T1,TResult&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeRight&lt;T1, TResult&gt;(!!T1 arg, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!TResult&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeRight``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_PipeRight(Of T1, TResult) (arg As T1, func As FSharpFunc(Of T1, TResult)) As TResult" />
      <MemberSignature Language="F#" Value="( |&gt; ) : 'T1 -&gt; ('T1 -&gt; 'Result) -&gt; 'Result" Usage="arg |&gt; func" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg" Type="T1" />
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="arg">The argument.</param>
        <param name="func">The function.</param>
        <summary>Apply a function to a value, the value being on the left, the function on the right</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeRight2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeRight2&lt;T1,T2,TResult&gt; (T1 arg1, T2 arg2, Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeRight2&lt;T1, T2, TResult&gt;(!!T1 arg1, !!T2 arg2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeRight2``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_PipeRight2(Of T1, T2, TResult) (arg1 As T1, arg2 As T2, func As FSharpFunc(Of T1, FSharpFunc(Of T2, TResult))) As TResult" />
      <MemberSignature Language="F#" Value="( ||&gt; ) : 'T1 * 'T2 -&gt; ('T1 -&gt; 'T2 -&gt; 'Result) -&gt; 'Result" Usage="(arg1, arg2) ||&gt; func" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg1" Type="T1" />
        <Parameter Name="arg2" Type="T2" />
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="arg1">The first argument.</param>
        <param name="arg2">The second argument.</param>
        <param name="func">The function.</param>
        <summary>Apply a function to two values, the values being a pair on the left, the function on the right</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeRight3&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeRight3&lt;T1,T2,T3,TResult&gt; (T1 arg1, T2 arg2, T3 arg3, Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeRight3&lt;T1, T2, T3, TResult&gt;(!!T1 arg1, !!T2 arg2, !!T3 arg3, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T3, !!TResult&gt;&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeRight3``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_PipeRight3(Of T1, T2, T3, TResult) (arg1 As T1, arg2 As T2, arg3 As T3, func As FSharpFunc(Of T1, FSharpFunc(Of T2, FSharpFunc(Of T3, TResult)))) As TResult" />
      <MemberSignature Language="F#" Value="( |||&gt; ) : 'T1 * 'T2 * 'T3 -&gt; ('T1 -&gt; 'T2 -&gt; 'T3 -&gt; 'Result) -&gt; 'Result" Usage="(arg1, arg2, arg3) |||&gt; func" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg1" Type="T1" />
        <Parameter Name="arg2" Type="T2" />
        <Parameter Name="arg3" Type="T3" />
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="arg1">The first argument.</param>
        <param name="arg2">The second argument.</param>
        <param name="arg3">The third argument.</param>
        <param name="func">The function.</param>
        <summary>Apply a function to three values, the values being a triple on the left, the function on the right</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Range&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; op_Range&lt;T&gt; (T start, T finish);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; op_Range&lt;T&gt;(!!T start, !!T finish) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Range``1(``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Range(Of T) (start As T, finish As T) As IEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="( .. ) : 'T -&gt; 'T -&gt; seq&lt;'T&gt;" Usage="start .. finish" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="start" Type="T" />
        <Parameter Name="finish" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="start">The start value of the range.</param>
        <param name="finish">The end value of the range.</param>
        <summary>The standard overloaded range operator, e.g. <c>[n..m]</c> for lists, <c>seq {n..m}</c> for sequences</summary>
        <returns>The sequence spanning the range.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RangeStep&lt;T,TStep&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; op_RangeStep&lt;T,TStep&gt; (T start, TStep step, T finish);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; op_RangeStep&lt;T, TStep&gt;(!!T start, !!TStep step, !!T finish) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_RangeStep``2(``0,``1,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_RangeStep(Of T, TStep) (start As T, step As TStep, finish As T) As IEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="( .. .. ) : 'T -&gt; 'Step -&gt; 'T -&gt; seq&lt;'T&gt;" Usage="start .. step .. finish" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TStep" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="start" Type="T" />
        <Parameter Name="step" Type="TStep" />
        <Parameter Name="finish" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TStep">To be added.</typeparam>
        <param name="start">The start value of the range.</param>
        <param name="step">The step value of the range.</param>
        <param name="finish">The end value of the range.</param>
        <summary>The standard overloaded skip range operator, e.g. <c>[n..skip..m]</c> for lists, <c>seq {n..skip..m}</c> for sequences</summary>
        <returns>The sequence spanning the range using the specified step size.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T operator &gt;&gt;&lt;T&gt; (T value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_RightShift&lt;T&gt;(!!T value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_RightShift``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt;(Of T) (value As T, shift As Integer) As T" />
      <MemberSignature Language="F#" Value="( &gt;&gt;&gt; ) : 'T -&gt; int -&gt; 'T" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <param name="shift">The amount to shift.</param>
        <summary>Overloaded byte-shift right operator by a specified number of bits</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 operator -&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Subtraction&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Subtraction``3(``0,``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator -(Of T1, T2, T3) (x As T1, y As T2) As T3" />
      <MemberSignature Language="F#" Value="( - ) : 'T1 -&gt; 'T2 -&gt; 'T3" Usage="x - y" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded subtraction operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T operator -&lt;T&gt; (T n);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_UnaryNegation&lt;T&gt;(!!T n) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_UnaryNegation``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator -(Of T) (n As T) As T" />
      <MemberSignature Language="F#" Value="( ~- ) : 'T -&gt; 'T" Usage="- n" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="n" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="n">The value to negate.</param>
        <summary>Overloaded unary negation.</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T operator +&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_UnaryPlus&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_UnaryPlus``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator +(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="( ~+ ) : 'T -&gt; 'T" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Overloaded prefix-plus operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowInteger&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PowInteger&lt;T&gt; (T x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T PowInteger&lt;T&gt;(!!T x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.PowInteger``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PowInteger(Of T) (x As T, n As Integer) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.pown : 'T -&gt; int -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.PowInteger x n" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="n" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input base.</param>
        <param name="n">The input exponent.</param>
        <summary>Overloaded power operator. If <c>n &gt; 0</c> then equivalent to <c>x*...*x</c> for <c>n</c> occurrences of <c>x</c>. </summary>
        <returns>The base raised to the exponent.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Raise&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Raise&lt;T&gt; (Exception exn);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Raise&lt;T&gt;(class System.Exception exn) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Raise``1(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Raise(Of T) (exn As Exception) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.raise : Exception -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Raise exn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("raise")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exn" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="exn">The exception to raise.</param>
        <summary>Raises an exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ref&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpRef&lt;T&gt; Ref&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpRef`1&lt;!!T&gt; Ref&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Ref``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ref(Of T) (value As T) As FSharpRef(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.ref : 'T -&gt; ref&lt;'T&gt;" Usage="Microsoft.FSharp.Core.Operators.Ref value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ref")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpRef&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to contain in the cell.</param>
        <summary>Create a mutable reference cell</summary>
        <returns>The created reference cell.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reraise&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Reraise&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Reraise&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Reraise``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reraise(Of T) () As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.reraise : unit -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Reraise " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reraise")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Rethrows an exception. This should only be used when handling an exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Rethrow&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Rethrow&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Rethrow``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rethrow(Of T) () As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.rethrow : unit -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Rethrow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("rethrow")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This function has been renamed to 'reraise'. Please adjust your code to reflect this", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Rethrows an exception. This should only be used when handling an exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Round&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Round&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Round``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.round : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Round value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("round")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Round the given number</summary>
        <returns>The nearest integer to the input value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Sign&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Sign&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Sign``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign(Of T) (value As T) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.sign : 'T -&gt; int" Usage="Microsoft.FSharp.Core.Operators.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sign")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Sign of the given number</summary>
        <returns>-1, 0, or 1 depending on the sign of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sin&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Sin&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Sin``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.sin : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sin")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Sine of the given number</summary>
        <returns>The sine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sinh&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Sinh&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Sinh``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.sinh : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sinh")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Hyperbolic sine of the given number</summary>
        <returns>The hyperbolic sine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.SizeOf``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) () As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.sizeof : unit -&gt; int" Usage="Microsoft.FSharp.Core.Operators.SizeOf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sizeof")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.RequiresExplicitTypeArguments</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Returns the internal size of a type in bytes. For example, <c>sizeof&lt;int&gt;</c> returns 4.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Snd&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static T2 Snd&lt;T1,T2&gt; (Tuple&lt;T1,T2&gt; tuple);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T2 Snd&lt;T1, T2&gt;(class System.Tuple`2&lt;!!T1, !!T2&gt; tuple) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Snd``2(System.Tuple{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Snd(Of T1, T2) (tuple As Tuple(Of T1, T2)) As T2" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.snd : ('T1 * 'T2) -&gt; 'T2" Usage="Microsoft.FSharp.Core.Operators.Snd tuple" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("snd")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tuple" Type="System.Tuple&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="tuple">The input tuple.</param>
        <summary>Return the second element of a tuple, <c>snd (a,b) = b</c>.</summary>
        <returns>The second value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Sqrt&lt;T,TResult&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult Sqrt&lt;T, TResult&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Sqrt``2(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt(Of T, TResult) (value As T) As TResult" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.sqrt : 'T -&gt; 'Result" Usage="Microsoft.FSharp.Core.Operators.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sqrt")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Square root of the given number</summary>
        <returns>The square root of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Tan&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Tan&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Tan``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.tan : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tan")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Tangent of the given number</summary>
        <returns>The tangent of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Tanh&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Tanh&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Tanh``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.tanh : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tanh")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Hyperbolic tangent of the given number</summary>
        <returns>The hyperbolic tangent of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByte&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static byte ToByte&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8 ToByte&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToByte``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToByte(Of T) (value As T) As Byte" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.byte : 'T -&gt; byte" Usage="Microsoft.FSharp.Core.Operators.ToByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("byte")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Byte.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted byte</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToChar&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static char ToChar&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static char ToChar&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToChar``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToChar(Of T) (value As T) As Char" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.char : 'T -&gt; char" Usage="Microsoft.FSharp.Core.Operators.ToChar value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("char")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to character. Numeric inputs are converted according to the UTF-16 
 encoding for characters. String inputs must be exactly one character long. For other
 input types the operation requires an appropriate static conversion method on the input type.</summary>
        <returns>The converted char.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Decimal ToDecimal&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToDecimal``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToDecimal(Of T) (value As T) As Decimal" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.decimal : 'T -&gt; decimal" Usage="Microsoft.FSharp.Core.Operators.ToDecimal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("decimal")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to System.Decimal using a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted decimal.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static double ToDouble&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static float64 ToDouble&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToDouble``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToDouble(Of T) (value As T) As Double" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.float : 'T -&gt; double" Usage="Microsoft.FSharp.Core.Operators.ToDouble value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("float")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted float</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToEnum&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult ToEnum&lt;TResult&gt; (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult ToEnum&lt;TResult&gt;(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToEnum``1(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToEnum(Of TResult) (value As Integer) As TResult" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.enum : int -&gt; 'Result" Usage="Microsoft.FSharp.Core.Operators.ToEnum value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("enum")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to a particular enum type.</summary>
        <returns>The converted enum type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int ToInt&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 ToInt&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToInt``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt(Of T) (value As T) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.int : 'T -&gt; int" Usage="Microsoft.FSharp.Core.Operators.ToInt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("int")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted int</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt16&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static short ToInt16&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int16 ToInt16&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToInt16``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt16(Of T) (value As T) As Short" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.int16 : 'T -&gt; int16" Usage="Microsoft.FSharp.Core.Operators.ToInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("int16")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int16.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted int16</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt32&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int ToInt32&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 ToInt32&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToInt32``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt32(Of T) (value As T) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.int32 : 'T -&gt; int" Usage="Microsoft.FSharp.Core.Operators.ToInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("int32")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted int32</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static long ToInt64&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 ToInt64&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToInt64``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt64(Of T) (value As T) As Long" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.int64 : 'T -&gt; int64" Usage="Microsoft.FSharp.Core.Operators.ToInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("int64")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int64.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted int64</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToIntPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr ToIntPtr&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static native int ToIntPtr&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToIntPtr``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToIntPtr(Of T) (value As T) As IntPtr" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.nativeint : 'T -&gt; nativeint" Usage="Microsoft.FSharp.Core.Operators.ToIntPtr value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("nativeint")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted nativeint</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSByte&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int8 ToSByte&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToSByte``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToSByte(Of T) (value As T) As SByte" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.sbyte : 'T -&gt; sbyte" Usage="Microsoft.FSharp.Core.Operators.ToSByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sbyte")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>SByte.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted sbyte</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static float ToSingle&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static float32 ToSingle&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToSingle``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToSingle(Of T) (value As T) As Single" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.float32 : 'T -&gt; single" Usage="Microsoft.FSharp.Core.Operators.ToSingle value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("float32")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted float32</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ToString&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToString``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToString(Of T) (value As T) As String" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.string : 'T -&gt; string" Usage="Microsoft.FSharp.Core.Operators.ToString value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("string")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to a string using <c>ToString</c>.</summary>
        <returns>The converted string.</returns>
        <remarks>For standard integer and floating point values the <c>ToString</c> conversion 
 uses <c>CultureInfo.InvariantCulture</c>. </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int16 ToUInt16&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToUInt16``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUInt16(Of T) (value As T) As UShort" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.uint16 : 'T -&gt; uint16" Usage="Microsoft.FSharp.Core.Operators.ToUInt16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("uint16")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt16.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted uint16</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static uint ToUInt32&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int32 ToUInt32&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToUInt32``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUInt32(Of T) (value As T) As UInteger" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.uint32 : 'T -&gt; uint32" Usage="Microsoft.FSharp.Core.Operators.ToUInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("uint32")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted uint32</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int64 ToUInt64&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToUInt64``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUInt64(Of T) (value As T) As ULong" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.uint64 : 'T -&gt; uint64" Usage="Microsoft.FSharp.Core.Operators.ToUInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("uint64")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted uint64</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUIntPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIntPtr ToUIntPtr&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static native unsigned int ToUIntPtr&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToUIntPtr``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUIntPtr(Of T) (value As T) As UIntPtr" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.unativeint : 'T -&gt; unativeint" Usage="Microsoft.FSharp.Core.Operators.ToUIntPtr value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unativeint")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to unsigned native integer using a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted unativeint</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Truncate&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Truncate&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Truncate``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate(Of T) (value As T) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.truncate : 'T -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Truncate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("truncate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Overloaded truncate operator.</summary>
        <returns>The truncated value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnbox&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryUnbox&lt;T&gt; (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryUnbox&lt;T&gt;(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.TryUnbox``1(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryUnbox(Of T) (value As Object) As FSharpOption(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.tryUnbox : obj -&gt; option&lt;'T&gt;" Usage="Microsoft.FSharp.Core.Operators.TryUnbox value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryUnbox")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The boxed value.</param>
        <summary>Try to unbox a strongly typed value.</summary>
        <returns>The unboxed result as an option.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeDefOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Type TypeDefOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Type TypeDefOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.TypeDefOf``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TypeDefOf(Of T) () As Type" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.typedefof : unit -&gt; Type" Usage="Microsoft.FSharp.Core.Operators.TypeDefOf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("typedefof")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.RequiresExplicitTypeArguments</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Generate a System.Type representation for a type definition. If the
 input type is a generic type instantiation then return the 
 generic type definition associated with all such instantiations.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Type TypeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Type TypeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.TypeOf``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TypeOf(Of T) () As Type" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.typeof : unit -&gt; Type" Usage="Microsoft.FSharp.Core.Operators.TypeOf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("typeof")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.RequiresExplicitTypeArguments</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Generate a System.Type runtime representation of a static type.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Unbox&lt;T&gt; (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Unbox&lt;T&gt;(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Unbox``1(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unbox(Of T) (value As Object) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.unbox : obj -&gt; 'T" Usage="Microsoft.FSharp.Core.Operators.Unbox value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unbox")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The boxed value.</param>
        <summary>Unbox a strongly typed value.</summary>
        <returns>The unboxed result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Using&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Using&lt;T,TResult&gt; (T resource, Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; action) where T : IDisposable;" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult Using&lt;(class System.IDisposable) T, TResult&gt;(!!T resource, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Using(Of T As IDisposable, TResult As IDisposable) (resource As T, action As FSharpFunc(Of T, TResult)) As TResult" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Core.Operators.using : 'T -&gt; ('T -&gt; 'Result (requires 'T :&gt; IDisposable)) -&gt; 'Result (requires 'T :&gt; IDisposable)" Usage="Microsoft.FSharp.Core.Operators.Using resource action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("using")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IDisposable</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="resource" Type="T" />
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="resource">The resource to be disposed after action is called.</param>
        <param name="action">The action that accepts the resource.</param>
        <summary>Clean up resources associated with the input object after the completion of the given function.
 Cleanup occurs even when an exception is raised by the protected
 code. </summary>
        <returns>The resulting value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>