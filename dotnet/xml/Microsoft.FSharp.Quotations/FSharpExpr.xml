<Type Name="FSharpExpr" FullName="Microsoft.FSharp.Quotations.FSharpExpr">
  <TypeSignature Language="C#" Value="public class FSharpExpr" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable FSharpExpr extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Quotations.FSharpExpr" />
  <TypeSignature Language="VB.NET" Value="Public Class FSharpExpr" />
  <TypeSignature Language="F#" Value="type Expr = class" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.Class</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.ObjectType)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompiledName("FSharpExpr")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Quoted expressions annotated with System.Type values. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AddressOf">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr AddressOf (Microsoft.FSharp.Quotations.FSharpExpr target);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr AddressOf(class Microsoft.FSharp.Quotations.FSharpExpr target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressOf(Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddressOf (target As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member AddressOf : Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.AddressOf target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="target">The target expression.</param>
        <summary>Builds an expression that represents getting the address of a value.</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressSet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr AddressSet (Microsoft.FSharp.Quotations.FSharpExpr target, Microsoft.FSharp.Quotations.FSharpExpr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr AddressSet(class Microsoft.FSharp.Quotations.FSharpExpr target, class Microsoft.FSharp.Quotations.FSharpExpr value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.AddressSet(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddressSet (target As FSharpExpr, value As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member AddressSet : Expr * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.AddressSet (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="value" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="target">The target expression.</param>
        <param name="value">The value to set at the address.</param>
        <summary>Builds an expression that represents setting the value held at a particular address.</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Application (Microsoft.FSharp.Quotations.FSharpExpr functionExpr, Microsoft.FSharp.Quotations.FSharpExpr argument);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Application(class Microsoft.FSharp.Quotations.FSharpExpr functionExpr, class Microsoft.FSharp.Quotations.FSharpExpr argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Application(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Application (functionExpr As FSharpExpr, argument As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Application : Expr * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Application (functionExpr, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionExpr" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="argument" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="functionExpr">The function to apply.</param>
        <param name="argument">The argument to the function.</param>
        <summary>Builds an expression that represents the application of a first class function value to a single argument.</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Applications">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Applications (Microsoft.FSharp.Quotations.FSharpExpr functionExpr, Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Applications(class Microsoft.FSharp.Quotations.FSharpExpr functionExpr, class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Applications(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Applications (functionExpr As FSharpExpr, arguments As FSharpList(Of FSharpList(Of FSharpExpr))) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Applications : Expr * List&lt;List&lt;Expr&gt;&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Applications (functionExpr, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionExpr" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="arguments" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="functionExpr">The function to apply.</param>
        <param name="arguments">The list of lists of arguments to the function.</param>
        <summary>Builds an expression that represents the application of a first class function value to multiple arguments</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Call (System.Reflection.MethodInfo methodInfo, Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Call(class System.Reflection.MethodInfo methodInfo, class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})" />
      <MemberSignature Language="F#" Value="static member Call : System.Reflection.MethodInfo * List&lt;Expr&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Call (methodInfo, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;" />
      </Parameters>
      <Docs>
        <param name="methodInfo">The MethodInfo describing the method to call.</param>
        <param name="arguments">The list of arguments to the method.</param>
        <summary>Builds an expression that represents a call to an static method or module-bound function</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Call (Microsoft.FSharp.Quotations.FSharpExpr obj, System.Reflection.MethodInfo methodInfo, Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Call(class Microsoft.FSharp.Quotations.FSharpExpr obj, class System.Reflection.MethodInfo methodInfo, class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Call(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.MethodInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})" />
      <MemberSignature Language="F#" Value="static member Call : Expr * System.Reflection.MethodInfo * List&lt;Expr&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Call (obj, methodInfo, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="arguments" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;" />
      </Parameters>
      <Docs>
        <param name="obj">The input object.</param>
        <param name="methodInfo">The description of the method to call.</param>
        <param name="arguments">The list of arguments to the method.</param>
        <summary>Builds an expression that represents a call to an instance method associated with an object</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr&lt;T&gt; Cast&lt;T&gt; (Microsoft.FSharp.Quotations.FSharpExpr source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr`1&lt;!!T&gt; Cast&lt;T&gt;(class Microsoft.FSharp.Quotations.FSharpExpr source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Cast``1(Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cast(Of T) (source As FSharpExpr) As FSharpExpr(Of T)" />
      <MemberSignature Language="F#" Value="static member Cast : Expr -&gt; Expr&lt;'T&gt;" Usage="Microsoft.FSharp.Quotations.Expr.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The expression to cast.</param>
        <summary>Returns a new typed expression given an underlying runtime-typed expression.
 A type annotation is usually required to use this function, and 
 using an incorrect type annotation may result in a later runtime exception.</summary>
        <returns>The resulting typed expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Coerce">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Coerce (Microsoft.FSharp.Quotations.FSharpExpr source, Type target);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Coerce(class Microsoft.FSharp.Quotations.FSharpExpr source, class System.Type target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Coerce(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Coerce (source As FSharpExpr, target As Type) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Coerce : Expr * Type -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Coerce (source, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="target" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="source">The expression to coerce.</param>
        <param name="target">The target type.</param>
        <summary>Builds an expression that represents the coercion of an expression to a type</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Quotations.FSharpExpr.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CustomAttributes As FSharpList(Of FSharpExpr)" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : List&lt;Expr&gt;" Usage="Microsoft.FSharp.Quotations.Expr.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the custom attributes of an expression.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr DefaultValue (Type expressionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr DefaultValue(class System.Type expressionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.DefaultValue(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DefaultValue (expressionType As Type) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member DefaultValue : Type -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.DefaultValue expressionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expressionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="expressionType">The type on which the constructor is invoked.</param>
        <summary>Builds an expression that represents the invocation of a default object constructor</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Deserialize (Type qualifyingType, Microsoft.FSharp.Collections.FSharpList&lt;Type&gt; spliceTypes, Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; spliceExprs, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Deserialize(class System.Type qualifyingType, class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Type&gt; spliceTypes, class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; spliceExprs, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Deserialize(System.Type,Microsoft.FSharp.Collections.FSharpList{System.Type},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr},System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Deserialize (qualifyingType As Type, spliceTypes As FSharpList(Of Type), spliceExprs As FSharpList(Of FSharpExpr), bytes As Byte()) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Deserialize : Type * List&lt;Type&gt; * List&lt;Expr&gt; * byte[] -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Deserialize (qualifyingType, spliceTypes, spliceExprs, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifyingType" Type="System.Type" />
        <Parameter Name="spliceTypes" Type="Microsoft.FSharp.Collections.FSharpList&lt;System.Type&gt;" />
        <Parameter Name="spliceExprs" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="qualifyingType">A type in the assembly where the quotation occurs.</param>
        <param name="spliceTypes">The spliced types, to replace references to type variables.</param>
        <param name="spliceExprs">The spliced expressions to replace references to spliced expressions.</param>
        <param name="bytes">The serialized form of the quoted expression.</param>
        <summary>This function is called automatically when quotation syntax (&lt;@ @&gt;) and other sources of
 quotations are used. </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deserialize40">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Deserialize40 (Type qualifyingType, Type[] referencedTypes, Type[] spliceTypes, Microsoft.FSharp.Quotations.FSharpExpr[] spliceExprs, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Deserialize40(class System.Type qualifyingType, class System.Type[] referencedTypes, class System.Type[] spliceTypes, class Microsoft.FSharp.Quotations.FSharpExpr[] spliceExprs, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Deserialize40(System.Type,System.Type[],System.Type[],Microsoft.FSharp.Quotations.FSharpExpr[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Deserialize40 (qualifyingType As Type, referencedTypes As Type(), spliceTypes As Type(), spliceExprs As FSharpExpr(), bytes As Byte()) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Deserialize40 : Type * Type[] * Type[] * Expr[] * byte[] -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Deserialize40 (qualifyingType, referencedTypes, spliceTypes, spliceExprs, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifyingType" Type="System.Type" />
        <Parameter Name="referencedTypes" Type="System.Type[]" />
        <Parameter Name="spliceTypes" Type="System.Type[]" />
        <Parameter Name="spliceExprs" Type="Microsoft.FSharp.Quotations.FSharpExpr[]" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="qualifyingType">A type in the assembly where the quotation occurs.</param>
        <param name="referencedTypes">The type definitions referenced.</param>
        <param name="spliceTypes">The spliced types, to replace references to type variables.</param>
        <param name="spliceExprs">The spliced expressions to replace references to spliced expressions.</param>
        <param name="bytes">The serialized form of the quoted expression.</param>
        <summary>This function is called automatically when quotation syntax (&lt;@ @&gt;) and other sources of
 quotations are used. </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="expr.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldGet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr FieldGet (System.Reflection.FieldInfo fieldInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr FieldGet(class System.Reflection.FieldInfo fieldInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(System.Reflection.FieldInfo)" />
      <MemberSignature Language="F#" Value="static member FieldGet : System.Reflection.FieldInfo -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.FieldGet fieldInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="fieldInfo">The description of the field to access.</param>
        <summary>Builds an expression that represents the access of a static field</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldGet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr FieldGet (Microsoft.FSharp.Quotations.FSharpExpr obj, System.Reflection.FieldInfo fieldInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr FieldGet(class Microsoft.FSharp.Quotations.FSharpExpr obj, class System.Reflection.FieldInfo fieldInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo)" />
      <MemberSignature Language="F#" Value="static member FieldGet : Expr * System.Reflection.FieldInfo -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.FieldGet (obj, fieldInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="obj">The input object.</param>
        <param name="fieldInfo">The description of the field to access.</param>
        <summary>Builds an expression that represents the access of a field of an object</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldSet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr FieldSet (System.Reflection.FieldInfo fieldInfo, Microsoft.FSharp.Quotations.FSharpExpr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr FieldSet(class System.Reflection.FieldInfo fieldInfo, class Microsoft.FSharp.Quotations.FSharpExpr value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="F#" Value="static member FieldSet : System.Reflection.FieldInfo * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.FieldSet (fieldInfo, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" />
        <Parameter Name="value" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="fieldInfo">The description of the field to write to.</param>
        <param name="value">The value to the set to the field.</param>
        <summary>Builds an expression that represents writing to a static field </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldSet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr FieldSet (Microsoft.FSharp.Quotations.FSharpExpr obj, System.Reflection.FieldInfo fieldInfo, Microsoft.FSharp.Quotations.FSharpExpr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr FieldSet(class Microsoft.FSharp.Quotations.FSharpExpr obj, class System.Reflection.FieldInfo fieldInfo, class Microsoft.FSharp.Quotations.FSharpExpr value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.FieldSet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.FieldInfo,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="F#" Value="static member FieldSet : Expr * System.Reflection.FieldInfo * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.FieldSet (obj, fieldInfo, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="fieldInfo" Type="System.Reflection.FieldInfo" />
        <Parameter Name="value" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="obj">The input object.</param>
        <param name="fieldInfo">The description of the field to write to.</param>
        <param name="value">The value to set to the field.</param>
        <summary>Builds an expression that represents writing to a field of an object</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForIntegerRangeLoop">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr ForIntegerRangeLoop (Microsoft.FSharp.Quotations.FSharpVar loopVariable, Microsoft.FSharp.Quotations.FSharpExpr start, Microsoft.FSharp.Quotations.FSharpExpr endExpr, Microsoft.FSharp.Quotations.FSharpExpr body);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr ForIntegerRangeLoop(class Microsoft.FSharp.Quotations.FSharpVar loopVariable, class Microsoft.FSharp.Quotations.FSharpExpr start, class Microsoft.FSharp.Quotations.FSharpExpr endExpr, class Microsoft.FSharp.Quotations.FSharpExpr body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.ForIntegerRangeLoop(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForIntegerRangeLoop (loopVariable As FSharpVar, start As FSharpExpr, endExpr As FSharpExpr, body As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member ForIntegerRangeLoop : Var * Expr * Expr * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.ForIntegerRangeLoop (loopVariable, start, endExpr, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loopVariable" Type="Microsoft.FSharp.Quotations.FSharpVar" />
        <Parameter Name="start" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="endExpr" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="body" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="loopVariable">The sub-expression declaring the loop variable.</param>
        <param name="start">The sub-expression setting the initial value of the loop variable.</param>
        <param name="endExpr">The sub-expression declaring the final value of the loop variable.</param>
        <param name="body">The sub-expression representing the body of the loop.</param>
        <summary>Builds a 'for i = ... to ... do ...' expression that represent loops over integer ranges</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFreeVars">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Quotations.FSharpVar&gt; GetFreeVars ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.FSharp.Quotations.FSharpVar&gt; GetFreeVars() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.GetFreeVars" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFreeVars () As IEnumerable(Of FSharpVar)" />
      <MemberSignature Language="F#" Value="member this.GetFreeVars : unit -&gt; seq&lt;Var&gt;" Usage="expr.GetFreeVars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Quotations.FSharpVar&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the free expression variables of an expression as a list.</summary>
        <returns>A sequence of the free variables in the expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="expr.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalVar&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr&lt;T&gt; GlobalVar&lt;T&gt; (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr`1&lt;!!T&gt; GlobalVar&lt;T&gt;(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.GlobalVar``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GlobalVar(Of T) (name As String) As FSharpExpr(Of T)" />
      <MemberSignature Language="F#" Value="static member GlobalVar : string -&gt; Expr&lt;'T&gt;" Usage="Microsoft.FSharp.Quotations.Expr.GlobalVar name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="name">The variable name.</param>
        <summary>Fetches or creates a new variable with the given name and type from a global pool of shared variables
 indexed by name and type. The type is given by the explicit or inferred type parameter</summary>
        <returns>The created of fetched typed global variable.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IfThenElse">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr IfThenElse (Microsoft.FSharp.Quotations.FSharpExpr guard, Microsoft.FSharp.Quotations.FSharpExpr thenExpr, Microsoft.FSharp.Quotations.FSharpExpr elseExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr IfThenElse(class Microsoft.FSharp.Quotations.FSharpExpr guard, class Microsoft.FSharp.Quotations.FSharpExpr thenExpr, class Microsoft.FSharp.Quotations.FSharpExpr elseExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.IfThenElse(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IfThenElse (guard As FSharpExpr, thenExpr As FSharpExpr, elseExpr As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member IfThenElse : Expr * Expr * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.IfThenElse (guard, thenExpr, elseExpr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guard" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="thenExpr" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="elseExpr" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="guard">The condition expression.</param>
        <param name="thenExpr">The <c>then</c> sub-expression.</param>
        <param name="elseExpr">The <c>else</c> sub-expression.</param>
        <summary>Builds 'if ... then ... else' expressions.</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Lambda (Microsoft.FSharp.Quotations.FSharpVar parameter, Microsoft.FSharp.Quotations.FSharpExpr body);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Lambda(class Microsoft.FSharp.Quotations.FSharpVar parameter, class Microsoft.FSharp.Quotations.FSharpExpr body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Lambda(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (parameter As FSharpVar, body As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Lambda : Var * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Lambda (parameter, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="Microsoft.FSharp.Quotations.FSharpVar" />
        <Parameter Name="body" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="parameter">The parameter to the function.</param>
        <param name="body">The body of the function.</param>
        <summary>Builds an expression that represents the construction of an F# function value</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Let">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Let (Microsoft.FSharp.Quotations.FSharpVar letVariable, Microsoft.FSharp.Quotations.FSharpExpr letExpr, Microsoft.FSharp.Quotations.FSharpExpr body);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Let(class Microsoft.FSharp.Quotations.FSharpVar letVariable, class Microsoft.FSharp.Quotations.FSharpExpr letExpr, class Microsoft.FSharp.Quotations.FSharpExpr body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Let(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Let (letVariable As FSharpVar, letExpr As FSharpExpr, body As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Let : Var * Expr * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Let (letVariable, letExpr, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="letVariable" Type="Microsoft.FSharp.Quotations.FSharpVar" />
        <Parameter Name="letExpr" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="body" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="letVariable">The variable in the let expression.</param>
        <param name="letExpr">The expression bound to the variable.</param>
        <param name="body">The sub-expression where the binding is in scope.</param>
        <summary>Builds expressions associated with 'let' constructs</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LetRecursive">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr LetRecursive (Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; bindings, Microsoft.FSharp.Quotations.FSharpExpr body);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr LetRecursive(class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`2&lt;class Microsoft.FSharp.Quotations.FSharpVar, class Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; bindings, class Microsoft.FSharp.Quotations.FSharpExpr body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.LetRecursive(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr}},Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LetRecursive (bindings As FSharpList(Of Tuple(Of FSharpVar, FSharpExpr)), body As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member LetRecursive : List&lt;Var * Expr&gt; * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.LetRecursive (bindings, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindings" Type="Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt;" />
        <Parameter Name="body" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="bindings">The list of bindings for the let expression.</param>
        <param name="body">The sub-expression where the bindings are in scope.</param>
        <summary>Builds recursive expressions associated with 'let rec' constructs</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewArray">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr NewArray (Type elementType, Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr NewArray(class System.Type elementType, class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.NewArray(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NewArray (elementType As Type, elements As FSharpList(Of FSharpExpr)) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member NewArray : Type * List&lt;Expr&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.NewArray (elementType, elements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="elements" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;" />
      </Parameters>
      <Docs>
        <param name="elementType">The type for the elements of the array.</param>
        <param name="elements">The list of elements of the array.</param>
        <summary>Builds an expression that represents the creation of an array value initialized with the given elements</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewDelegate">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr NewDelegate (Type delegateType, Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpVar&gt; parameters, Microsoft.FSharp.Quotations.FSharpExpr body);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr NewDelegate(class System.Type delegateType, class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpVar&gt; parameters, class Microsoft.FSharp.Quotations.FSharpExpr body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.NewDelegate(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpVar},Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NewDelegate (delegateType As Type, parameters As FSharpList(Of FSharpVar), body As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member NewDelegate : Type * List&lt;Var&gt; * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.NewDelegate (delegateType, parameters, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="parameters" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpVar&gt;" />
        <Parameter Name="body" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="delegateType">The type of delegate.</param>
        <param name="parameters">The parameters for the delegate.</param>
        <param name="body">The body of the function.</param>
        <summary>Builds an expression that represents the creation of a delegate value for the given type</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewObject">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr NewObject (System.Reflection.ConstructorInfo constructorInfo, Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr NewObject(class System.Reflection.ConstructorInfo constructorInfo, class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.NewObject(System.Reflection.ConstructorInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})" />
      <MemberSignature Language="F#" Value="static member NewObject : System.Reflection.ConstructorInfo * List&lt;Expr&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.NewObject (constructorInfo, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructorInfo" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="arguments" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;" />
      </Parameters>
      <Docs>
        <param name="constructorInfo">The description of the constructor.</param>
        <param name="arguments">The list of arguments to the constructor.</param>
        <summary>Builds an expression that represents the invocation of an object constructor</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRecord">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr NewRecord (Type recordType, Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr NewRecord(class System.Type recordType, class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.NewRecord(System.Type,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NewRecord (recordType As Type, elements As FSharpList(Of FSharpExpr)) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member NewRecord : Type * List&lt;Expr&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.NewRecord (recordType, elements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recordType" Type="System.Type" />
        <Parameter Name="elements" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;" />
      </Parameters>
      <Docs>
        <param name="recordType">The type of record.</param>
        <param name="elements">The list of elements of the record.</param>
        <summary>Builds record-construction expressions </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewTuple">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr NewTuple (Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; elements);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr NewTuple(class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; elements) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.NewTuple(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NewTuple (elements As FSharpList(Of FSharpExpr)) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member NewTuple : List&lt;Expr&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.NewTuple elements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elements" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;" />
      </Parameters>
      <Docs>
        <param name="elements">The list of elements of the tuple.</param>
        <summary>Builds an expression that represents the creation of an F# tuple value</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewUnionCase">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr NewUnionCase (Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr NewUnionCase(class Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.NewUnionCase(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NewUnionCase (unionCase As UnionCaseInfo, arguments As FSharpList(Of FSharpExpr)) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member NewUnionCase : Microsoft.FSharp.Reflection.UnionCaseInfo * List&lt;Expr&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.NewUnionCase (unionCase, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unionCase" Type="Microsoft.FSharp.Reflection.UnionCaseInfo" />
        <Parameter Name="arguments" Type="Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;" />
      </Parameters>
      <Docs>
        <param name="unionCase">The description of the union case.</param>
        <param name="arguments">The list of arguments for the case.</param>
        <summary>Builds an expression that represents the creation of a union case value</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyGet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr PropertyGet (System.Reflection.PropertyInfo property, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; indexerArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr PropertyGet(class System.Reflection.PropertyInfo property, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; indexerArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PropertyGet (property As PropertyInfo, indexerArgs As FSharpOption(Of FSharpList(Of FSharpExpr))) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member PropertyGet : System.Reflection.PropertyInfo * option&lt;List&lt;Expr&gt;&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.PropertyGet (property, indexerArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="indexerArgs" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="property">The description of the property.</param>
        <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>
        <summary>Builds an expression that represents reading a static property </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyGet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr PropertyGet (Microsoft.FSharp.Quotations.FSharpExpr obj, System.Reflection.PropertyInfo property, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; indexerArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr PropertyGet(class Microsoft.FSharp.Quotations.FSharpExpr obj, class System.Reflection.PropertyInfo property, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; indexerArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertyGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PropertyGet (obj As FSharpExpr, property As PropertyInfo, indexerArgs As FSharpOption(Of FSharpList(Of FSharpExpr))) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member PropertyGet : Expr * System.Reflection.PropertyInfo * option&lt;List&lt;Expr&gt;&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.PropertyGet (obj, property, indexerArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="indexerArgs" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="obj">The input object.</param>
        <param name="property">The description of the property.</param>
        <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>
        <summary>Builds an expression that represents reading a property of an object</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertySet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr PropertySet (System.Reflection.PropertyInfo property, Microsoft.FSharp.Quotations.FSharpExpr value, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; indexerArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr PropertySet(class System.Reflection.PropertyInfo property, class Microsoft.FSharp.Quotations.FSharpExpr value, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; indexerArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PropertySet (property As PropertyInfo, value As FSharpExpr, indexerArgs As FSharpOption(Of FSharpList(Of FSharpExpr))) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member PropertySet : System.Reflection.PropertyInfo * Expr * option&lt;List&lt;Expr&gt;&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.PropertySet (property, value, indexerArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="value" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="indexerArgs" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="property">The description of the property.</param>
        <param name="value">The value to set.</param>
        <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>
        <summary>Builds an expression that represents writing to a static property </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertySet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr PropertySet (Microsoft.FSharp.Quotations.FSharpExpr obj, System.Reflection.PropertyInfo property, Microsoft.FSharp.Quotations.FSharpExpr value, Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; indexerArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr PropertySet(class Microsoft.FSharp.Quotations.FSharpExpr obj, class System.Reflection.PropertyInfo property, class Microsoft.FSharp.Quotations.FSharpExpr value, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; indexerArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.PropertySet(Microsoft.FSharp.Quotations.FSharpExpr,System.Reflection.PropertyInfo,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Quotations.FSharpExpr}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PropertySet (obj As FSharpExpr, property As PropertyInfo, value As FSharpExpr, indexerArgs As FSharpOption(Of FSharpList(Of FSharpExpr))) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member PropertySet : Expr * System.Reflection.PropertyInfo * Expr * option&lt;List&lt;Expr&gt;&gt; -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.PropertySet (obj, property, value, indexerArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="property" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="value" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="indexerArgs" Type="Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="obj">The input object.</param>
        <param name="property">The description of the property.</param>
        <param name="value">The value to set.</param>
        <param name="indexerArgs">List of indices for the property if it is an indexed property.</param>
        <summary>Builds an expression that represents writing to a property of an object</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Quote">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Quote (Microsoft.FSharp.Quotations.FSharpExpr inner);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Quote(class Microsoft.FSharp.Quotations.FSharpExpr inner) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Quote(Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Quote (inner As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Quote : Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Quote inner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Please use Expr.QuoteTyped or Expr.QuoteRaw to distinguish between typed and raw quotation literals")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inner" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="inner">The expression being quoted.</param>
        <summary>Builds an expression that represents a nested typed or raw quotation literal</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QuoteRaw">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr QuoteRaw (Microsoft.FSharp.Quotations.FSharpExpr inner);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr QuoteRaw(class Microsoft.FSharp.Quotations.FSharpExpr inner) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.QuoteRaw(Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QuoteRaw (inner As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member QuoteRaw : Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.QuoteRaw inner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inner" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="inner">The expression being quoted.</param>
        <summary>Builds an expression that represents a nested raw quotation literal</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QuoteTyped">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr QuoteTyped (Microsoft.FSharp.Quotations.FSharpExpr inner);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr QuoteTyped(class Microsoft.FSharp.Quotations.FSharpExpr inner) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.QuoteTyped(Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QuoteTyped (inner As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member QuoteTyped : Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.QuoteTyped inner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inner" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="inner">The expression being quoted.</param>
        <summary>Builds an expression that represents a nested typed quotation literal</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReflectedDefinitions">
      <MemberSignature Language="C#" Value="public static void RegisterReflectedDefinitions (System.Reflection.Assembly assembly, string resource, byte[] serializedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RegisterReflectedDefinitions(class System.Reflection.Assembly assembly, string resource, unsigned int8[] serializedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.RegisterReflectedDefinitions(System.Reflection.Assembly,System.String,System.Byte[])" />
      <MemberSignature Language="F#" Value="static member RegisterReflectedDefinitions : System.Reflection.Assembly * string * byte[] -&gt; unit" Usage="Microsoft.FSharp.Quotations.Expr.RegisterReflectedDefinitions (assembly, resource, serializedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="serializedValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="assembly">The assembly associated with the resource.</param>
        <param name="resource">The unique name for the resources being added.</param>
        <param name="serializedValue">The serialized resource to register with the environment.</param>
        <summary>Permits interactive environments such as F# Interactive
 to explicitly register new pickled resources that represent persisted 
 top level definitions.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReflectedDefinitions">
      <MemberSignature Language="C#" Value="public static void RegisterReflectedDefinitions (System.Reflection.Assembly assembly, string resource, byte[] serializedValue, Type[] referencedTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RegisterReflectedDefinitions(class System.Reflection.Assembly assembly, string resource, unsigned int8[] serializedValue, class System.Type[] referencedTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.RegisterReflectedDefinitions(System.Reflection.Assembly,System.String,System.Byte[],System.Type[])" />
      <MemberSignature Language="F#" Value="static member RegisterReflectedDefinitions : System.Reflection.Assembly * string * byte[] * Type[] -&gt; unit" Usage="Microsoft.FSharp.Quotations.Expr.RegisterReflectedDefinitions (assembly, resource, serializedValue, referencedTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
        <Parameter Name="resource" Type="System.String" />
        <Parameter Name="serializedValue" Type="System.Byte[]" />
        <Parameter Name="referencedTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="assembly">The assembly associated with the resource.</param>
        <param name="resource">The unique name for the resources being added.</param>
        <param name="serializedValue">The serialized resource to register with the environment.</param>
        <param name="referencedTypes">The type definitions referenced.</param>
        <summary>Permits interactive environments such as F# Interactive
 to explicitly register new pickled resources that represent persisted 
 top level definitions.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sequential">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Sequential (Microsoft.FSharp.Quotations.FSharpExpr first, Microsoft.FSharp.Quotations.FSharpExpr second);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Sequential(class Microsoft.FSharp.Quotations.FSharpExpr first, class Microsoft.FSharp.Quotations.FSharpExpr second) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Sequential(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sequential (first As FSharpExpr, second As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Sequential : Expr * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Sequential (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="second" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="first">The first expression.</param>
        <param name="second">The second expression.</param>
        <summary>Builds an expression that represents the sequential execution of one expression followed by another</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substitute">
      <MemberSignature Language="C#" Value="public Microsoft.FSharp.Quotations.FSharpExpr Substitute (Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; substitution);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.FSharp.Quotations.FSharpExpr Substitute(class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Quotations.FSharpVar, class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt; substitution) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Substitute(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Quotations.FSharpExpr}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Substitute (substitution As FSharpFunc(Of FSharpVar, FSharpOption(Of FSharpExpr))) As FSharpExpr" />
      <MemberSignature Language="F#" Value="member this.Substitute : (Var -&gt; option&lt;Expr&gt;) -&gt; Expr" Usage="expr.Substitute substitution" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="substitution" Type="Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="substitution">The function to map variables into expressions.</param>
        <summary>Substitutes through the given expression using the given functions
 to map variables to new values. The functions must give consistent results
 at each application. Variable renaming may occur on the target expression
 if variable capture occurs.</summary>
        <returns>The expression with the given substitutions.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expr.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool full);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool full) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.ToString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (full As Boolean) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : bool -&gt; string" Usage="expr.ToString full" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="full" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="full">Indicates if method, property, constructor and type objects should be printed in detail. If false, these are abbreviated to their name.</param>
        <summary>Format the expression as a string</summary>
        <returns>The formatted string.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr TryFinally (Microsoft.FSharp.Quotations.FSharpExpr body, Microsoft.FSharp.Quotations.FSharpExpr compensation);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr TryFinally(class Microsoft.FSharp.Quotations.FSharpExpr body, class Microsoft.FSharp.Quotations.FSharpExpr compensation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.TryFinally(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFinally (body As FSharpExpr, compensation As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member TryFinally : Expr * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.TryFinally (body, compensation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="compensation" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="body">The body of the try expression.</param>
        <param name="compensation">The final part of the expression to be evaluated.</param>
        <summary>Builds an expression that represents a try/finally construct </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetReflectedDefinition">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt; TryGetReflectedDefinition (System.Reflection.MethodBase methodBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;class Microsoft.FSharp.Quotations.FSharpExpr&gt; TryGetReflectedDefinition(class System.Reflection.MethodBase methodBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.TryGetReflectedDefinition(System.Reflection.MethodBase)" />
      <MemberSignature Language="F#" Value="static member TryGetReflectedDefinition : System.Reflection.MethodBase -&gt; option&lt;Expr&gt;" Usage="Microsoft.FSharp.Quotations.Expr.TryGetReflectedDefinition methodBase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;Microsoft.FSharp.Quotations.FSharpExpr&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodBase" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="methodBase">The description of the method to find.</param>
        <summary>Try and find a stored reflection definition for the given method. Stored reflection
 definitions are added to an F# assembly through the use of the [&lt;ReflectedDefinition&gt;] attribute.</summary>
        <returns>The reflection definition or None if a match could not be found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWith">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr TryWith (Microsoft.FSharp.Quotations.FSharpExpr body, Microsoft.FSharp.Quotations.FSharpVar filterVar, Microsoft.FSharp.Quotations.FSharpExpr filterBody, Microsoft.FSharp.Quotations.FSharpVar catchVar, Microsoft.FSharp.Quotations.FSharpExpr catchBody);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr TryWith(class Microsoft.FSharp.Quotations.FSharpExpr body, class Microsoft.FSharp.Quotations.FSharpVar filterVar, class Microsoft.FSharp.Quotations.FSharpExpr filterBody, class Microsoft.FSharp.Quotations.FSharpVar catchVar, class Microsoft.FSharp.Quotations.FSharpExpr catchBody) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.TryWith(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWith (body As FSharpExpr, filterVar As FSharpVar, filterBody As FSharpExpr, catchVar As FSharpVar, catchBody As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member TryWith : Expr * Var * Expr * Var * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.TryWith (body, filterVar, filterBody, catchVar, catchBody)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="body" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="filterVar" Type="Microsoft.FSharp.Quotations.FSharpVar" />
        <Parameter Name="filterBody" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="catchVar" Type="Microsoft.FSharp.Quotations.FSharpVar" />
        <Parameter Name="catchBody" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="body">The body of the try expression.</param>
        <param name="filterVar"></param>
        <param name="filterBody"></param>
        <param name="catchVar">The variable to bind to a caught exception.</param>
        <param name="catchBody">The expression evaluated when an exception is caught.</param>
        <summary>Builds an expression that represents a try/with construct for exception filtering and catching.</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TupleGet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr TupleGet (Microsoft.FSharp.Quotations.FSharpExpr tuple, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr TupleGet(class Microsoft.FSharp.Quotations.FSharpExpr tuple, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.TupleGet(Microsoft.FSharp.Quotations.FSharpExpr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TupleGet (tuple As FSharpExpr, index As Integer) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member TupleGet : Expr * int -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.TupleGet (tuple, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tuple" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tuple">The input tuple.</param>
        <param name="index">The index of the tuple element to get.</param>
        <summary>Builds an expression that represents getting a field of a tuple</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Type Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Quotations.FSharpExpr.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As Type" />
      <MemberSignature Language="F#" Value="member this.Type : Type" Usage="Microsoft.FSharp.Quotations.Expr.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns type of an expression.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeTest">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr TypeTest (Microsoft.FSharp.Quotations.FSharpExpr source, Type target);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr TypeTest(class Microsoft.FSharp.Quotations.FSharpExpr source, class System.Type target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.TypeTest(Microsoft.FSharp.Quotations.FSharpExpr,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TypeTest (source As FSharpExpr, target As Type) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member TypeTest : Expr * Type -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.TypeTest (source, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="target" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="source">The expression to test.</param>
        <param name="target">The target type.</param>
        <summary>Builds an expression that represents a type test.</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionCaseTest">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr UnionCaseTest (Microsoft.FSharp.Quotations.FSharpExpr source, Microsoft.FSharp.Reflection.UnionCaseInfo unionCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr UnionCaseTest(class Microsoft.FSharp.Quotations.FSharpExpr source, class Microsoft.FSharp.Reflection.UnionCaseInfo unionCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.UnionCaseTest(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Reflection.UnionCaseInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnionCaseTest (source As FSharpExpr, unionCase As UnionCaseInfo) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member UnionCaseTest : Expr * Microsoft.FSharp.Reflection.UnionCaseInfo -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.UnionCaseTest (source, unionCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="unionCase" Type="Microsoft.FSharp.Reflection.UnionCaseInfo" />
      </Parameters>
      <Docs>
        <param name="source">The expression to test.</param>
        <param name="unionCase">The description of the union case.</param>
        <summary>Builds an expression that represents a test of a value is of a particular union case</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Value (object value, Type expressionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Value(object value, class System.Type expressionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Value(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Value (value As Object, expressionType As Type) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Value : obj * Type -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Value (value, expressionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="expressionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">The untyped object.</param>
        <param name="expressionType">The type of the object.</param>
        <summary>Builds an expression that represents a constant value of a particular type</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Value&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Value&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Value``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Value(Of T) (value As T) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Value : 'T -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Value value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The typed value.</param>
        <summary>Builds an expression that represents a constant value </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueWithName">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr ValueWithName (object value, Type expressionType, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr ValueWithName(object value, class System.Type expressionType, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.ValueWithName(System.Object,System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueWithName (value As Object, expressionType As Type, name As String) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member ValueWithName : obj * Type * string -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.ValueWithName (value, expressionType, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="expressionType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The untyped object.</param>
        <param name="expressionType">The type of the object.</param>
        <param name="name">The name of the variable.</param>
        <summary>Builds an expression that represents a constant value of a particular type, arising from a variable of the given name </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueWithName&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr ValueWithName&lt;T&gt; (T value, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr ValueWithName&lt;T&gt;(!!T value, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.ValueWithName``1(``0,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueWithName(Of T) (value As T, name As String) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member ValueWithName : 'T * string -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.ValueWithName (value, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The typed value.</param>
        <param name="name">The name of the variable.</param>
        <summary>Builds an expression that represents a constant value, arising from a variable of the given name </summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Var">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr Var (Microsoft.FSharp.Quotations.FSharpVar variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr Var(class Microsoft.FSharp.Quotations.FSharpVar variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.Var(Microsoft.FSharp.Quotations.FSharpVar)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Var (variable As FSharpVar) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member Var : Var -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.Var variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="Microsoft.FSharp.Quotations.FSharpVar" />
      </Parameters>
      <Docs>
        <param name="variable">The input variable.</param>
        <summary>Builds an expression that represents a variable</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VarSet">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr VarSet (Microsoft.FSharp.Quotations.FSharpVar variable, Microsoft.FSharp.Quotations.FSharpExpr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr VarSet(class Microsoft.FSharp.Quotations.FSharpVar variable, class Microsoft.FSharp.Quotations.FSharpExpr value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.VarSet(Microsoft.FSharp.Quotations.FSharpVar,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VarSet (variable As FSharpVar, value As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member VarSet : Var * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.VarSet (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="Microsoft.FSharp.Quotations.FSharpVar" />
        <Parameter Name="value" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="variable">The input variable.</param>
        <param name="value">The value to set.</param>
        <summary>Builds an expression that represents setting a mutable variable</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WhileLoop">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr WhileLoop (Microsoft.FSharp.Quotations.FSharpExpr guard, Microsoft.FSharp.Quotations.FSharpExpr body);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr WhileLoop(class Microsoft.FSharp.Quotations.FSharpExpr guard, class Microsoft.FSharp.Quotations.FSharpExpr body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.WhileLoop(Microsoft.FSharp.Quotations.FSharpExpr,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhileLoop (guard As FSharpExpr, body As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member WhileLoop : Expr * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.WhileLoop (guard, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guard" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
        <Parameter Name="body" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="guard">The predicate to control the loop iteration.</param>
        <param name="body">The body of the while loop.</param>
        <summary>Builds an expression that represents a while loop</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithValue">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr WithValue (object value, Type expressionType, Microsoft.FSharp.Quotations.FSharpExpr definition);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr WithValue(object value, class System.Type expressionType, class Microsoft.FSharp.Quotations.FSharpExpr definition) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.WithValue(System.Object,System.Type,Microsoft.FSharp.Quotations.FSharpExpr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WithValue (value As Object, expressionType As Type, definition As FSharpExpr) As FSharpExpr" />
      <MemberSignature Language="F#" Value="static member WithValue : obj * Type * Expr -&gt; Expr" Usage="Microsoft.FSharp.Quotations.Expr.WithValue (value, expressionType, definition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="expressionType" Type="System.Type" />
        <Parameter Name="definition" Type="Microsoft.FSharp.Quotations.FSharpExpr" />
      </Parameters>
      <Docs>
        <param name="value">The untyped object.</param>
        <param name="expressionType">The type of the object.</param>
        <param name="definition">The definition of the value being quoted.</param>
        <summary>Builds an expression that represents a value and its associated reflected definition as a quotation</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WithValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Quotations.FSharpExpr&lt;T&gt; WithValue&lt;T&gt; (T value, Microsoft.FSharp.Quotations.FSharpExpr&lt;T&gt; definition);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Quotations.FSharpExpr`1&lt;!!T&gt; WithValue&lt;T&gt;(!!T value, class Microsoft.FSharp.Quotations.FSharpExpr`1&lt;!!T&gt; definition) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Quotations.FSharpExpr.WithValue``1(``0,Microsoft.FSharp.Quotations.FSharpExpr{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WithValue(Of T) (value As T, definition As FSharpExpr(Of T)) As FSharpExpr(Of T)" />
      <MemberSignature Language="F#" Value="static member WithValue : 'T * Expr&lt;'T&gt; -&gt; Expr&lt;'T&gt;" Usage="Microsoft.FSharp.Quotations.Expr.WithValue (value, definition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Quotations.FSharpExpr&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="definition" Type="Microsoft.FSharp.Quotations.FSharpExpr&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value being quoted.</param>
        <param name="definition">The definition of the value being quoted.</param>
        <summary>Builds an expression that represents a value and its associated reflected definition as a quotation</summary>
        <returns>The resulting expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>