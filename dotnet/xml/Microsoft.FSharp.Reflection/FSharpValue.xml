<Type Name="FSharpValue" FullName="Microsoft.FSharp.Reflection.FSharpValue">
  <TypeSignature Language="C#" Value="public static class FSharpValue" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed FSharpValue extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Reflection.FSharpValue" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.4.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.AbstractClass</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.ObjectType)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.Sealed</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Contains operations associated with constructing and analyzing values associated with F# types
 such as records, unions and tuples.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="GetExceptionFields">
      <MemberSignature Language="C#" Value="public static object[] GetExceptionFields (object exn, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static object[] GetExceptionFields(object exn, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.GetExceptionFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exn" Type="System.Object" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="exn">The exception instance.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Reads all the fields from a value built using an instance of an F# exception declaration</summary>
        <returns>The fields from the given exception.</returns>
        <remarks>Assumes the given input is an F# exception value. If not, ArgumentException is raised.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input type is not an F# exception.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRecordField">
      <MemberSignature Language="C#" Value="public static object GetRecordField (object record, System.Reflection.PropertyInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetRecordField(object record, class System.Reflection.PropertyInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordField(System.Object,System.Reflection.PropertyInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="record" Type="System.Object" />
        <Parameter Name="info" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="record">The record object.</param>
        <param name="info">The PropertyInfo describing the field to read.</param>
        <summary>Reads a field from a record value.</summary>
        <returns>The field from the record.</returns>
        <remarks>Assumes the given input is a record value. If not, ArgumentException is raised.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRecordFields">
      <MemberSignature Language="C#" Value="public static object[] GetRecordFields (object record, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static object[] GetRecordFields(object record, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.GetRecordFields(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="record" Type="System.Object" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="record">The record object.</param>
        <param name="bindingFlags">Optional binding flags for the record.</param>
        <summary>Reads all the fields from a record value.</summary>
        <returns>The array of fields from the record.</returns>
        <remarks>Assumes the given input is a record value. If not, ArgumentException is raised.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTupleField">
      <MemberSignature Language="C#" Value="public static object GetTupleField (object tuple, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetTupleField(object tuple, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleField(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tuple" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tuple">The input tuple.</param>
        <param name="index">The index of the field to read.</param>
        <summary>Reads a field from a tuple value.</summary>
        <returns>The value of the field.</returns>
        <remarks>Assumes the given input is a tuple value. If not, ArgumentException is raised.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTupleFields">
      <MemberSignature Language="C#" Value="public static object[] GetTupleFields (object tuple);" />
      <MemberSignature Language="ILAsm" Value=".method public static object[] GetTupleFields(object tuple) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.GetTupleFields(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tuple" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tuple">The input tuple.</param>
        <summary>Reads all fields from a tuple.</summary>
        <returns>An array of the fields from the given tuple.</returns>
        <remarks>Assumes the given input is a tuple value. If not, ArgumentException is raised.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input is not a tuple value.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUnionFields">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Reflection.UnionCaseInfo,object[]&gt; GetUnionFields (object value, Type unionType, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class Microsoft.FSharp.Reflection.UnionCaseInfo, object[]&gt; GetUnionFields(object value, class System.Type unionType, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.GetUnionFields(System.Object,System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="unionType" Type="System.Type" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">The input union case.</param>
        <param name="unionType">The union type containing the value.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Identify the union case and its fields for an object</summary>
        <returns>The description of the union case and its fields.</returns>
        <remarks>Assumes the given input is a union case value. If not, ArgumentException is raised.

 If the type is not given, then the runtime type of the input object is used to identify the
 relevant union type. The type should always be given if the input object may be null. For example, 
 option values may be represented using the 'null'.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input type is not a union case value.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeFunction">
      <MemberSignature Language="C#" Value="public static object MakeFunction (Type functionType, Microsoft.FSharp.Core.FSharpFunc&lt;object,object&gt; implementation);" />
      <MemberSignature Language="ILAsm" Value=".method public static object MakeFunction(class System.Type functionType, class Microsoft.FSharp.Core.FSharpFunc`2&lt;object, object&gt; implementation) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.MakeFunction(System.Type,Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Object})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionType" Type="System.Type" />
        <Parameter Name="implementation" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Object,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="functionType">The function type of the implementation.</param>
        <param name="implementation">The untyped lambda of the function implementation.</param>
        <summary>Builds a typed function from object from a dynamic function implementation</summary>
        <returns>A typed function from the given dynamic implementation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeRecord">
      <MemberSignature Language="C#" Value="public static object MakeRecord (Type recordType, object[] values, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static object MakeRecord(class System.Type recordType, object[] values, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.MakeRecord(System.Type,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recordType" Type="System.Type" />
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="recordType">The type of record to make.</param>
        <param name="values">The array of values to initialize the record.</param>
        <param name="bindingFlags">Optional binding flags for the record.</param>
        <summary>Creates an instance of a record type.</summary>
        <returns>The created record.</returns>
        <remarks>Assumes the given input is a record type.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeTuple">
      <MemberSignature Language="C#" Value="public static object MakeTuple (object[] tupleElements, Type tupleType);" />
      <MemberSignature Language="ILAsm" Value=".method public static object MakeTuple(object[] tupleElements, class System.Type tupleType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(System.Object[],System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tupleElements" Type="System.Object[]" />
        <Parameter Name="tupleType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tupleElements">The array of tuple fields.</param>
        <param name="tupleType">The tuple type to create.</param>
        <summary>Creates an instance of a tuple type</summary>
        <returns>An instance of the tuple type with the given elements.</returns>
        <remarks>Assumes at least one element is given. If not, ArgumentException is raised.</remarks>
        <exception cref="System.ArgumentException">Thrown if no elements are given.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeUnion">
      <MemberSignature Language="C#" Value="public static object MakeUnion (Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, object[] args, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static object MakeUnion(class Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, object[] args, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.MakeUnion(Microsoft.FSharp.Reflection.UnionCaseInfo,System.Object[],Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unionCase" Type="Microsoft.FSharp.Reflection.UnionCaseInfo" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="unionCase">The description of the union case to create.</param>
        <param name="args">The array of arguments to construct the given case.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Create a union case value.</summary>
        <returns>The constructed union case.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreComputeRecordConstructor">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;object[],object&gt; PreComputeRecordConstructor (Type recordType, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpFunc`2&lt;object[], object&gt; PreComputeRecordConstructor(class System.Type recordType, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructor(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;System.Object[],System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recordType" Type="System.Type" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="recordType">The type of record to construct.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Precompute a function for constructing a record value. </summary>
        <returns>A function to construct records of the given type.</returns>
        <remarks>Assumes the given type is a RecordType.
 If not, ArgumentException is raised during pre-computation.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
      </Docs>
    </Member>
    <Member MemberName="PreComputeRecordConstructorInfo">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo PreComputeRecordConstructorInfo (Type recordType, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Reflection.ConstructorInfo PreComputeRecordConstructorInfo(class System.Type recordType, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordConstructorInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recordType" Type="System.Type" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="recordType">The record type.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Get a ConstructorInfo for a record type</summary>
        <returns>A ConstructorInfo for the given record type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreComputeRecordFieldReader">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;object,object&gt; PreComputeRecordFieldReader (System.Reflection.PropertyInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpFunc`2&lt;object, object&gt; PreComputeRecordFieldReader(class System.Reflection.PropertyInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordFieldReader(System.Reflection.PropertyInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;System.Object,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Reflection.PropertyInfo" />
      </Parameters>
      <Docs>
        <param name="info">The PropertyInfo of the field to read.</param>
        <summary>Precompute a function for reading a particular field from a record.
 Assumes the given type is a RecordType with a field of the given name. 
 If not, ArgumentException is raised during pre-computation.</summary>
        <returns>A function to read the specified field from the record.</returns>
        <remarks>Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
      </Docs>
    </Member>
    <Member MemberName="PreComputeRecordReader">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;object,object[]&gt; PreComputeRecordReader (Type recordType, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpFunc`2&lt;object, object[]&gt; PreComputeRecordReader(class System.Type recordType, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeRecordReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;System.Object,System.Object[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recordType" Type="System.Type" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="recordType">The type of record to read.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Precompute a function for reading all the fields from a record. The fields are returned in the
 same order as the fields reported by a call to Microsoft.FSharp.Reflection.Type.GetInfo for
 this type.</summary>
        <returns>An optimized reader for the given record type.</returns>
        <remarks>Assumes the given type is a RecordType. 
 If not, ArgumentException is raised during pre-computation.

 Using the computed function will typically be faster than executing a corresponding call to Value.GetInfo
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input type is not a record type.</exception>
      </Docs>
    </Member>
    <Member MemberName="PreComputeTupleConstructor">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;object[],object&gt; PreComputeTupleConstructor (Type tupleType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpFunc`2&lt;object[], object&gt; PreComputeTupleConstructor(class System.Type tupleType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructor(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;System.Object[],System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tupleType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tupleType">The type of tuple to read.</param>
        <summary>Precompute a function for reading the values of a particular tuple type</summary>
        <returns>A function to read a particular tuple type.</returns>
        <remarks>Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.</remarks>
        <exception cref="System.ArgumentException">Thrown when the given type is not a tuple type.</exception>
      </Docs>
    </Member>
    <Member MemberName="PreComputeTupleConstructorInfo">
      <MemberSignature Language="C#" Value="public static Tuple&lt;System.Reflection.ConstructorInfo,Microsoft.FSharp.Core.FSharpOption&lt;Type&gt;&gt; PreComputeTupleConstructorInfo (Type tupleType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class System.Reflection.ConstructorInfo, class Microsoft.FSharp.Core.FSharpOption`1&lt;class System.Type&gt;&gt; PreComputeTupleConstructorInfo(class System.Type tupleType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleConstructorInfo(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;System.Reflection.ConstructorInfo,Microsoft.FSharp.Core.FSharpOption&lt;System.Type&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tupleType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tupleType">The input tuple type.</param>
        <summary>Gets a method that constructs objects of the given tuple type. 
 For small tuples, no additional type will be returned.</summary>
        <returns>The description of the tuple type constructor and an optional extra type
 for large tuples.</returns>
        <remarks>For large tuples, an additional type is returned indicating that
 a nested encoding has been used for the tuple type. In this case
 the suffix portion of the tuple type has the given type and an
 object of this type must be created and passed as the last argument 
 to the ConstructorInfo. A recursive call to PreComputeTupleConstructorInfo 
 can be used to determine the constructor for that the suffix type.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreComputeTuplePropertyInfo">
      <MemberSignature Language="C#" Value="public static Tuple&lt;System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption&lt;Tuple&lt;Type,int&gt;&gt;&gt; PreComputeTuplePropertyInfo (Type tupleType, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class System.Reflection.PropertyInfo, class Microsoft.FSharp.Core.FSharpOption`1&lt;class System.Tuple`2&lt;class System.Type, int32&gt;&gt;&gt; PreComputeTuplePropertyInfo(class System.Type tupleType, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTuplePropertyInfo(System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;System.Reflection.PropertyInfo,Microsoft.FSharp.Core.FSharpOption&lt;System.Tuple&lt;System.Type,System.Int32&gt;&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tupleType" Type="System.Type" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tupleType">The input tuple type.</param>
        <param name="index">The index of the tuple element to describe.</param>
        <summary>Gets information that indicates how to read a field of a tuple</summary>
        <returns>The description of the tuple element and an optional type and index if the tuple is big.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreComputeTupleReader">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;object,object[]&gt; PreComputeTupleReader (Type tupleType);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpFunc`2&lt;object, object[]&gt; PreComputeTupleReader(class System.Type tupleType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeTupleReader(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;System.Object,System.Object[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tupleType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tupleType">The tuple type to read.</param>
        <summary>Precompute a function for reading the values of a particular tuple type</summary>
        <returns>A function to read values of the given tuple type.</returns>
        <remarks>Assumes the given type is a TupleType.
 If not, ArgumentException is raised during pre-computation.</remarks>
        <exception cref="System.ArgumentException">Thrown when the given type is not a tuple type.</exception>
      </Docs>
    </Member>
    <Member MemberName="PreComputeUnionConstructor">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;object[],object&gt; PreComputeUnionConstructor (Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpFunc`2&lt;object[], object&gt; PreComputeUnionConstructor(class Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructor(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;System.Object[],System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unionCase" Type="Microsoft.FSharp.Reflection.UnionCaseInfo" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="unionCase">The description of the union case.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Precompute a function for constructing a discriminated union value for a particular union case. </summary>
        <returns>A function for constructing values of the given union case.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreComputeUnionConstructorInfo">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo PreComputeUnionConstructorInfo (Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Reflection.MethodInfo PreComputeUnionConstructorInfo(class Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionConstructorInfo(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unionCase" Type="Microsoft.FSharp.Reflection.UnionCaseInfo" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="unionCase">The description of the union case.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>A method that constructs objects of the given case</summary>
        <returns>The description of the constructor of the given union case.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreComputeUnionReader">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;object,object[]&gt; PreComputeUnionReader (Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpFunc`2&lt;object, object[]&gt; PreComputeUnionReader(class Microsoft.FSharp.Reflection.UnionCaseInfo unionCase, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionReader(Microsoft.FSharp.Reflection.UnionCaseInfo,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;System.Object,System.Object[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unionCase" Type="Microsoft.FSharp.Reflection.UnionCaseInfo" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="unionCase">The description of the union case to read.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Precompute a function for reading all the fields for a particular discriminator case of a union type</summary>
        <returns>A function to for reading the fields of the given union case.</returns>
        <remarks>Using the computed function will typically be faster than executing a corresponding call to GetFields</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreComputeUnionTagMemberInfo">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo PreComputeUnionTagMemberInfo (Type unionType, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Reflection.MemberInfo PreComputeUnionTagMemberInfo(class System.Type unionType, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagMemberInfo(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unionType" Type="System.Type" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="unionType">The type of union to read.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Precompute a property or static method for reading an integer representing the case tag of a union type.</summary>
        <returns>The description of the union case reader.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreComputeUnionTagReader">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;object,int&gt; PreComputeUnionTagReader (Type unionType, Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt; bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpFunc`2&lt;object, int32&gt; PreComputeUnionTagReader(class System.Type unionType, class Microsoft.FSharp.Core.FSharpOption`1&lt;valuetype System.Reflection.BindingFlags&gt; bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Reflection.FSharpValue.PreComputeUnionTagReader(System.Type,Microsoft.FSharp.Core.FSharpOption{System.Reflection.BindingFlags})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;System.Object,System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unionType" Type="System.Type" />
        <Parameter Name="bindingFlags" Type="Microsoft.FSharp.Core.FSharpOption&lt;System.Reflection.BindingFlags&gt;">
          <Attributes>
            <Attribute>
              <AttributeName>Microsoft.FSharp.Core.OptionalArgument</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="unionType">The type of union to optimize reading.</param>
        <param name="bindingFlags">Optional binding flags.</param>
        <summary>Assumes the given type is a union type. 
 If not, ArgumentException is raised during pre-computation.</summary>
        <returns>An optimized function to read the tags of the given union type.</returns>
        <remarks>Using the computed function is more efficient than calling GetUnionCase
 because the path executed by the computed function is optimized given the knowledge that it will be
 used to read values of the given type.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
